 /*Assigns a shift (by iteration) to selected employees on each day for a specified schedule
    period using a pre-set shift pattern or no pattern with manually selected hours. 
    If a shift or time-off day is already allocated for a selected employee on a
    particular day of the schedule period, then no shift is assigned for the 
    employee on that day so preserves holidays, manual shifts, emergency leave etc. 
    Also considers if contract is finished or not and if so then will not assign shifts after contract end date
    No other constraints are considered/included at this point.
    */
    @FXML
    private void automatedShifts1() throws ClassNotFoundException, SQLException, ParseException{
        
        LocalDate startDate = scheduleFromDate.getValue();
        LocalDate endDate = scheduleToDate.getValue(); 
        int shiftPattern = shiftPatternComboBox.getSelectionModel().getSelectedIndex()+1;
        int shiftType =  shiftTypeComboBox.getSelectionModel().getSelectedIndex()+1;
        LocalTime startTime = LocalTime.of(Integer.parseInt(startTimeHours.getSelectionModel().getSelectedItem()), Integer.parseInt(startTimeMinutes.getSelectionModel().getSelectedItem()));
        LocalTime finishTime = LocalTime.of(Integer.parseInt(finishTimeHours.getSelectionModel().getSelectedItem()), Integer.parseInt(finishTimeMinutes.getSelectionModel().getSelectedItem()));
        long schedulePeriod = ChronoUnit.DAYS.between(startDate, endDate)+1;  
        int totalHours = Duration.between(startTime, finishTime).toHoursPart();
        double shiftCost = 0;   
        double totalMinutes = Double.parseDouble(df.format((Duration.between(startTime, finishTime).toMinutesPart())*0.0166));        
        double totalDuration = totalHours + totalMinutes;
        
        if(selectedEmployeesTable.getItems().isEmpty()){
            
            Alert noSelection = new Alert(Alert.AlertType.ERROR);
            noSelection.setHeaderText("Please choose an employee or employees to allocate shifts");
            noSelection.showAndWait();
        }
        else{
   
            Alert createShiftConfirmation = new Alert(Alert.AlertType.CONFIRMATION);
            createShiftConfirmation.setHeaderText("Are you sure you want to create shifts automatically using the period and settings selected?");
            createShiftConfirmation.showAndWait();

            if(createShiftConfirmation.getResult().getText().equalsIgnoreCase("OK")){

                LocalDate date = scheduleFromDate.getValue();     
                employeesSelected.addAll(selectedEmployeesTable.getItems());
                
                //for each day in the chosen schedule period
                  for (int i=0; i < schedulePeriod; i++){

                        //for each of the selected employees
                        for (Employee employee : employeesSelected){

                            //calculate shift cost
                            shiftCost = Double.parseDouble(df.format((DAO.getHourlyRate(employee.getEmployeeID())) * totalDuration));

                            //Check if employee has shift/time-off on same date and if does not the to proceed. 
                            if(DAO.checkEmployeeShift(employee.getEmployeeID(), date.format(formatter))==false){

                            //Assign shift    
                            DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                            }               
                        }
                        //increment a day in the schedule period
                       date = date.plusDays(1);
                    }
                    Stage autoShedule = (Stage) this.autoShiftCancelButton.getScene().getWindow();
                    autoShedule.close();
                    
                    refreshCalendar();
            }            
        }             
    }    
    
    /*
    Same as automatedShifts1() above, however, considers (does not assign shifts on) employee preferred days off (soft constraints).
    Achieves 100% schedule quality based on preferred days off constraint being met for all selected employees 
    in the schedule period. No hard constraints included.
    */
    @FXML
    private void automatedShifts2() throws ClassNotFoundException, SQLException, ParseException{
        
        LocalDate startDate = scheduleFromDate.getValue();
        LocalDate endDate = scheduleToDate.getValue(); 
        int shiftPattern = shiftPatternComboBox.getSelectionModel().getSelectedIndex()+1;
        int shiftType =  shiftTypeComboBox.getSelectionModel().getSelectedIndex()+1;
        LocalTime startTime = LocalTime.of(Integer.parseInt(startTimeHours.getSelectionModel().getSelectedItem()), Integer.parseInt(startTimeMinutes.getSelectionModel().getSelectedItem()));
        LocalTime finishTime = LocalTime.of(Integer.parseInt(finishTimeHours.getSelectionModel().getSelectedItem()), Integer.parseInt(finishTimeMinutes.getSelectionModel().getSelectedItem()));
        long schedulePeriod = ChronoUnit.DAYS.between(startDate, endDate)+1;  
        int totalHours = Duration.between(startTime, finishTime).toHoursPart();
        double shiftCost = 0;   
        double totalMinutes = Double.parseDouble(df.format((Duration.between(startTime, finishTime).toMinutesPart())*0.0166));        
        double totalDuration = totalHours + totalMinutes;
            
        if(selectedEmployeesTable.getItems().isEmpty()){
            
            Alert noSelection = new Alert(Alert.AlertType.ERROR);
            noSelection.setHeaderText("Please choose an employee or employees to allocate shifts");
            noSelection.showAndWait();
        }
        else{                               
            Alert createShiftConfirmation = new Alert(Alert.AlertType.CONFIRMATION);
            createShiftConfirmation.setHeaderText("Are you sure you want to create shifts automatically using the period and settings selected?");
            createShiftConfirmation.showAndWait();

            if(createShiftConfirmation.getResult().getText().equalsIgnoreCase("OK")){

                 LocalDate date = scheduleFromDate.getValue(); 
                 employeesSelected.addAll(selectedEmployeesTable.getItems());

                 //for the schedule period selected
                  for (int i=0; i < schedulePeriod; i++){

                      //for each employee
                        for (Employee employee : employeesSelected){

                            //calculate the shift cose for the hours selected
                            shiftCost = Double.parseDouble(df.format((DAO.getHourlyRate(employee.getEmployeeID())) * totalDuration));
                            
                            //Check if employee has shift/time-off on same date and if does not the to proceed. 
                            if(DAO.checkEmployeeShift(employee.getEmployeeID(), date.format(formatter))==false){
                                 
                                    //check if the current employees preferred day off is on this date and if so then do not assign shift                               
                                    if(!(Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue())){
                                        
                                        if(!(Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue())){
                                        
                                        //Assign shift
                                        DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                                        }
                                    }                              
                            }               
                        }
                        //increment a day in the schedule period
                       date = date.plusDays(1);
                    }
                    Stage autoShedule = (Stage) this.autoShiftCancelButton.getScene().getWindow();
                    autoShedule.close();
                    
                    refreshCalendar();     
            }            
        }             
    }
    
    
    
    /*same as 1 and 2 but now includes all of the hard constraints which cannot be violated and also adds days off  
    * to preferred days off rather than just skipping this date.
    * 
    * Hard Constraints:
        Contract date not passed
        Contracted hours per week are not exceeded
        Pre-booked days off, sick days, emergency leave, annual leave preserved
        Minimum hours between shifts are not  exceeded
    *
    * Soft Constraints:
        Maximum consecutive working days not exceeded 
        Employee day off preference 1 met
        Employee day off preference 2 met
    *  
    */
    @FXML
    private void automatedShifts3() throws ClassNotFoundException, SQLException, ParseException, IOException, InterruptedException{
        
        //variables for the start and end dates of chosen schedule period
        LocalDate startDate = scheduleFromDate.getValue();
        LocalDate endDate = scheduleToDate.getValue(); 
        
        //variable for the selected shift pattern
        int shiftPattern = shiftPatternComboBox.getSelectionModel().getSelectedIndex()+1;
        
        //variable for the selected shift type
        int shiftType =  shiftTypeComboBox.getSelectionModel().getSelectedIndex()+1;
        
        //start and end times for chosen shift period
        LocalTime startTime = LocalTime.of(Integer.parseInt(startTimeHours.getSelectionModel().getSelectedItem()), Integer.parseInt(startTimeMinutes.getSelectionModel().getSelectedItem()));
        LocalTime finishTime = LocalTime.of(Integer.parseInt(finishTimeHours.getSelectionModel().getSelectedItem()), Integer.parseInt(finishTimeMinutes.getSelectionModel().getSelectedItem()));
        
        //variable for days between start and end dates for the selected schedule period
        long schedulePeriod = ChronoUnit.DAYS.between(startDate, endDate)+1;
        
        //variable for total number of hours in a assigned/selected shift
        int totalHours = Duration.ofHours(24).plus(Duration.between(startTime, finishTime)).toHoursPart();
           
        //variable for the minutes part of a assigned/selected shift. For example 8 hours and 15 minutes. This value would be 15 minutes.
        double totalMinutes = Double.parseDouble(df.format((Duration.between(startTime, finishTime).toMinutesPart())*0.0166));        
        
        //variable for total duration of a assigned shift
        double totalDuration = totalHours + totalMinutes;
        
        //variable shift cost value
        double shiftCost;
        
        //variable for holding the number of hours assigned to an employee in a week to evaluate for not exceeding the weekly contracted hours.
        double assignedHours1;        
       
        double progressBarIncrement = Double.parseDouble(df.format(1.00/schedulePeriod));                
       
        //validation check the user has selected at least one employee    
        if(selectedEmployeesTable.getItems().isEmpty()){
            
            Alert noSelection = new Alert(Alert.AlertType.ERROR);
            noSelection.setHeaderText("Please choose an employee or employees to allocate shifts");
            noSelection.showAndWait();
        }
        else{                   
            
            Alert createShiftConfirmation = new Alert(Alert.AlertType.CONFIRMATION);
            createShiftConfirmation.setHeaderText("Are you sure you want to create shifts automatically for the selected period, employees and settings?");
            createShiftConfirmation.showAndWait();

            if(createShiftConfirmation.getResult().getText().equalsIgnoreCase("OK")){
                                                
                //set date variable as the first date in the selected shedule period
                 LocalDate date = scheduleFromDate.getValue();                                           
                 employeesSelected.addAll(selectedEmployeesTable.getItems());
                 
                 //for each day in the schedule period
                  for (int i=0; i < schedulePeriod; i++){
                                            
                      //if any day falls on a Monday, reset the weekly assigned/allocated hours to 0.
                      if(date.getDayOfWeek().getValue()==1){
                                assignedHours1 = 0;
                                }
                                         
                      //for each employee selected for the projected schedule period  
                      for (Employee employee : employeesSelected){
                        
                        //set assigned/allocated hours count to 0  
                        assignedHours1=0;
                          
                        //get and store employee contract from database as we will need this for contract constraint checks
                        Contract contract = DAO.getContract(employee.getEmployeeContract());
                        
                        //store shift cost for each shift that will be created, based on the hourly rate in the current employee multiplied by the 
                        //duration of hours for the shift.
                        shiftCost = Double.parseDouble(df.format((DAO.getHourlyRate(employee.getEmployeeID())) * totalDuration));                                   
                                
                        //hard constraint - check that the current employee contract end date has not passed for this day in the projected schedule period
                        
                        if(!(date.isAfter(LocalDate.parse(contract.getContractEndDate())))){
                        //System.out.println("Contract end date check passed (line812)");                                               
                        //The following block of code then gets current number of working hours already assigned for the current employee, for the current week of current day
                        //of the projected schedule period.

                            //first set variables for finding the current week in the chosen schedule period and setting the start and end dates for this week
                            LocalDate startOfWeek = date.with(DayOfWeek.MONDAY);
                            LocalDate endOfWeek = date.with(DayOfWeek.SUNDAY);
                            long weekPeriod = startOfWeek.until(endOfWeek, DAYS)+1;//sets period of days to iterate through to check for existing shifts
                                                       
                            LocalDate day = startOfWeek;
                                                                                    
                                //for each day of the first week in the projected schedule period
                                for (int a=0; a < weekPeriod; a++){                            

                                    //check if there are any existing shifts assigned
                                    if(DAO.checkEmployeeShift(employee.getEmployeeID(), day.format(formatter))==true){                                                                              
                                        
                                        Shift shift = DAO.getEmployeeShift(employee.getEmployeeID(), day.format(formatter));
                                        //check that this is a working shifts
                                        if(shift.getShiftType().equalsIgnoreCase("1")){
                                        
                                        //if a shift is assigned then get the duration of hours for that planned shift    
                                        LocalTime shiftStart = LocalTime.parse(shift.getShiftStart());
                                        LocalTime shiftEnd = LocalTime.parse(shift.getShiftEnd());
                                        int hours1 = Duration.ofHours(24).plus(Duration.between(shiftStart, shiftEnd)).toHoursPart();
                                        double minutes1 = Double.parseDouble(df.format((Duration.between(shiftStart, shiftEnd).toMinutesPart())*0.0166)); 
                                        double duration1 = hours1 + minutes1;
                                        
                                        double assignedHours2 = 0;

                                        //add the duration to a total assigned to the employee for that week of the schedule period.
                                        assignedHours2 = Double.sum(assignedHours2, duration1);   
                                        assignedHours1 = Double.sum(assignedHours1, assignedHours2); //passes the total number of hours currentl assigned for the week to assignedHours1 
                                        }
                                     }                                                                                                                                               
                                    //increment a day and continue the loop to get all assigned hours for that week 
                                    day = day.plusDays(1);
                                }                                      
                                //end of calculating working hours for the week     
                               
                            //hard constraint - now check if the contracted weekly hours for the employee has and will not been exceeded
                            if (!(Double.sum(assignedHours1, totalDuration) > Double.parseDouble(contract.getContractedHours()))){
                                //System.out.println("Contracted weekly hours not exceeded check passed (line 855)");
                                                                                             
                                //hard constraint (sick days, annual leave, etc) - check if the current employee has a shift or any time-off already allocated on 
                                //the current date of the projected schedule period and if does, then to skip this day. 
                                if(!(DAO.checkEmployeeShift(employee.getEmployeeID(), date.format(formatter))==true)){
                                   //System.out.println("Existing shift on this date check passed (line 860)");              
                                     /*hard constraint - the following block checks if employee has a shift booked the day before the current date as if does, will need to check the constraint 
                                     for minimum hours between shifts has not been exceeded                        
                                     */
                                     
                                     //check if a shift exists the day before this day as if does, will need to check if minimum hours between the last shift and the next will not be exceeded
                                     if(DAO.checkEmployeeShift(employee.getEmployeeID(), date.minusDays(1).format(formatter))==true){
                                         //System.out.println("Check shift exists the day before check passed (line 867)");
                                         //if there is a shift booked for the day before, then get the end time for it as well as the start time of the new shift to work out the hours inbetween
                                         Shift shift2 = DAO.getEmployeeShift(employee.getEmployeeID(), date.minusDays(1).format(formatter));
                                       //check if the shift is a working shift  
                                       if(shift2.getShiftType().equalsIgnoreCase("1")){
                                           
                                                                                   
                                         LocalTime shiftEnd = LocalTime.parse(shift2.getShiftEnd());
                                         LocalTime shiftStart = startTime;
                                         int hours2 = Duration.ofHours(24).plus(Duration.between(shiftEnd, shiftStart)).toHoursPart();
                                         double minutes2 = Double.parseDouble(df.format((Duration.between(shiftEnd, shiftStart).toMinutesPart())*0.0166));
                                         double duration2 = hours2 + minutes2;
                                                                                  
                                                                     
                                            //hard constraint - now check that minimum hours between shifts as stated in the contract has not been exceeded
                                            if(duration2 >= Double.parseDouble(contract.getMinHoursBetweenShifts())){
                                                //System.out.println("Minimum hours between shifts check passed (line 883)");

                                                ////Now consider any soft constraints 

                                                //check if the current employees preferred days off 1 is on this date and if so then assign day off                               
                                                if(Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue()){
                                                    //System.out.println("Preferred day off 1 check passed(line 889) - assign day off");

                                                    //assign day off
                                                    DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                } 
                                                //check if the current employees preferred days off 2 is on this date and if so then assign day off 
                                                else if(Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue()){
                                                    //System.out.println("Preferred day off 2 check passed(line 896) - assign day off");

                                                    //assign day off
                                                    DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                }

                                               //before assigning a working shift check for consecutive working days before this date   
                                               else{ 
                                                    //System.out.println("Check consecutive working days (line 904)");
                                                   int consDays = Integer.parseInt(contract.getMaxConsWorkDays());
                                                   LocalDate startConsDays = date.minusDays(consDays); 
                                                   int consShifts = 0;

                                                   for (int b=0; b < consDays; b++){
                                                       
                                                    try{
                                                            Shift shift3 = DAO.getEmployeeShift(employee.getEmployeeID(), startConsDays.format(formatter));

                                                            if (shift3.getShiftType().equalsIgnoreCase("1")){
                                                                consShifts = consShifts + 1;
                                                            }                                                           

                                                        }

                                                    catch(NullPointerException s){

                                                            }
                                                    startConsDays = startConsDays.plusDays(1);
                                                   }
                                                   //System.out.println("cons loop 1: "+employee.getEmployeeName()+" "+ date +" "+ consShifts);
                                                   

                                                  //check if maximum consecutive working days has been reached and if so, assign a day off 
                                                  if (consShifts >= Integer.parseInt(contract.getMaxConsWorkDays())){
                                                      //System.out.println("Consecutive working days check failed (line 931) - assign day off");

                                                        //assign day off
                                                        DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                  }                                  
                                                  else {
                                                      //System.out.println("Consecutive working days check passed(line 937) - assign shift");
                                                    //Or finally, assign the working shift
                                                    DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                                                   }                                                                                        
                                                }
                                           }//if next shift starts before the minimum hours required between shifts
                                            else{
                                                //System.out.println("Minimum hours between shifts check failed (line 944)");
                                                //assign day off
                                                DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                            }                                   
                                      }
                                       else{
                                           //System.out.println("Existing shift is not a working shift (line 950)");
                                           
                                           //check if the current employees preferred days off 1 is on this date and if so then assign day off                               
                                                if(Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue()){
                                                    //System.out.println("Preferred day off 1 check passed(line 954) - assign day off");

                                                    //assign day off
                                                    DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                } 
                                                //check if the current employees preferred days off 2 is on this date and if so then assign day off 
                                                else if(Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue()){
                                                    //System.out.println("Preferred day off 2 check passed(line 961) - assign day off");

                                                    //assign day off
                                                    DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                }
                                                else {
                                                      //System.out.println("Consecutive working days check passed(line 967) - assign shift");
                                                    //Or finally, assign the working shift
                                                    DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                                                   }                                          
                                       }
                                         
                                    }//if the employee did not have a shift the day before the current date then can ignore checking min hours between shifts and 
                                     //continue the remainder of the loop - soft constraints
                                       
                                     
                                    //check if the current employees preferred days off is on this date and if so then assign the days off, else assign a working shift                              
                                    else { 
                                         //System.out.println("Check shift exists the day before check failed (line 979)");
                                         //check if the current employees preferred days off1 is on this date and if so then assign day off 
                                         if (Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue()){
                                             //System.out.println("Preferred day off 1 check passed(line 982) - assign day off");
                                                 //assign day off
                                                 DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                         } 
                                         //check if the current employees preferred days off2 is on this date and if so then assign day off 
                                         else if(Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue()){
                                                //System.out.println("Preferred day off 2 check passed(line 988) - assign day off");
                                                 //assign day off
                                                 DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                         }                              
                                         //before assaigning a shift, check if maximum consecutive days has been reached
                                         else {
                                             //System.out.println("Check consecutive working days (line 994)");
                                                int consDays2 = Integer.parseInt(contract.getMaxConsWorkDays());
                                                LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                int consShifts2 = 0;

                                                for (int c=0; c < consDays2; c++){
                                                    
                                                    try{                                                   
                                                            Shift shift4 = DAO.getEmployeeShift(employee.getEmployeeID(), startConsDays2.format(formatter));
                                                            if (shift4.getShiftType().equalsIgnoreCase("1")){//check if this is a working shift
                                                                consShifts2 = consShifts2 + 1;
                                                            }
                                                            //System.out.println("Actual Date in schedule: " + date);
                                                            //System.out.println("cons loop 2: "+employee.getEmployeeName()+" "+ startConsDays2 +" "+ consShifts2);
                                                        }

                                                    catch(NullPointerException s){

                                                            }
                                                    startConsDays2 = startConsDays2.plusDays(1);
                                                }     
                                                                                                                                                                                        
                                               //check if maximum consecutive working days has been reached and if so, assign a day off 
                                               if (consShifts2 >= Integer.parseInt(contract.getMaxConsWorkDays())){
                                                   //System.out.println("Check consecutive working days check failed(line 1018) - assign day off");                                                                                            
                                                     //assign day off
                                                     DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                               }                                  
                                               else {
                                                   //System.out.println("Check consecutive working days check passed(line 1023) - assign working shift"); 
                                                 //Or finally, assign the working shift
                                                 DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                                                }
                                            }
                                        }                           
                                }    
                            }
                            else{
                                //System.out.println("Contracted weekly hours has been exceeded (line 1032)");
                                //hard constraint (sick days, annual leave, etc) - check if the current employee has a shift or any time-off already allocated on 
                                //the current date of the projected schedule period and if does, then to skip this day. 
                                if(!(DAO.checkEmployeeShift(employee.getEmployeeID(), date.format(formatter))==true)){
                                    //System.out.println("Check for any pre-booked shifts passed (line 1036)");
                                    //check if the current employees preferred days off1 is on this date and if so then assign day off 
                                    if (Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue()){
                                        //System.out.println("Preferred day off 1 check passed(line 1039) - assign day off");
                                        //assign day off
                                        DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                    }
                                    //check if the current employees preferred days off2 is on this date and if so then assign day off 
                                    else if(Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue()){                                   
                                        //System.out.println("Preferred day off 2 check passed(line 1045) - assign day off");
                                        //assign day off
                                        DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                    }
                                    else{
                                        //System.out.println("Assign day off (line 1050)) - assign day off");
                                        //assign day off
                                        DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                    }
                                }                               
                            }                                             
                        }
                    }                     
                    //increment a day in the schedule period
                    //System.out.println("Increment a day in the schedule loop from: " + date + " to " + date.plusDays(1));                   
                    
                   date = date.plusDays(1);                  
                    
                } //complete the full loop for the remaining days of the schedule period
                  //System.out.println("Finished loop");
                  Stage autoShedule = (Stage) this.autoShiftCancelButton.getScene().getWindow();
                  autoShedule.close();

                  refreshCalendar();//update the calendar                 
            }            
        }             
    }
  
                

    /*
    * Same as 1, 2, and 3, with the addition of allowing the shift planner to set a limit (demand metric) on the 
    * number of staff required per day (as specified by them under optional settings). Once this limit has been reached
    * days off are assigned instead and moves to the next day. This still preserves employee preferred days off preference 
    * and consecutive before prioritising the ideal/set number of staff required per day.
    */
    @FXML
    private void automatedShifts4() throws ClassNotFoundException, SQLException, ParseException{
        
        //variables for the start and end dates of chosen schedule period
        LocalDate startDate = scheduleFromDate.getValue();
        LocalDate endDate = scheduleToDate.getValue(); 
        
        //variable for the selected shift pattern
        int shiftPattern = shiftPatternComboBox.getSelectionModel().getSelectedIndex()+1;
        
        //variable for the selected shift type
        int shiftType =  shiftTypeComboBox.getSelectionModel().getSelectedIndex()+1;
        
        //start and end times for chosen shift period
        LocalTime startTime = LocalTime.of(Integer.parseInt(startTimeHours.getSelectionModel().getSelectedItem()), Integer.parseInt(startTimeMinutes.getSelectionModel().getSelectedItem()));
        LocalTime finishTime = LocalTime.of(Integer.parseInt(finishTimeHours.getSelectionModel().getSelectedItem()), Integer.parseInt(finishTimeMinutes.getSelectionModel().getSelectedItem()));
        
        //variable for days between start and end dates for the selected schedule period
        long schedulePeriod = ChronoUnit.DAYS.between(startDate, endDate)+1;
        
        //variable for total number of hours in a assigned/selected shift
        int totalHours = Duration.ofHours(24).plus(Duration.between(startTime, finishTime)).toHoursPart();
           
        //variable for the minutes part of a assigned/selected shift. For example 8 hours and 15 minutes. This value would be 15 minutes.
        double totalMinutes = Double.parseDouble(df.format((Duration.between(startTime, finishTime).toMinutesPart())*0.0166));        
        
        //variable for total duration of a assigned shift
        double totalDuration = totalHours + totalMinutes;
        
        //variable shift cost value
        double shiftCost;
        
        //variable for holding the number of hours assigned to an employee in a week to evaluate for not exceeding the weekly contracted hours.
        double assignedHours1;
        
        //variable for holding number of shifts on a day to meet ideal number of employees required on a day constraint.
        int numOfShiftsOnDay;
        
       
        //validation check the user has selected at least one employee    
        if(selectedEmployeesTable.getItems().isEmpty()){
            
            Alert noSelection = new Alert(Alert.AlertType.ERROR);
            noSelection.setHeaderText("Please choose an employee or employees to allocate shifts");
            noSelection.showAndWait();
        }
        else if((allDaysTick.isSelected() && allDays.getText().isBlank()) || (monTick.isSelected() && mon.getText().isBlank()) || (tueTick.isSelected() && tue.getText().isBlank())
                || (wedTick.isSelected() && wed.getText().isBlank()) || (thuTick.isSelected() && thu.getText().isBlank()) || (friTick.isSelected() && fri.getText().isBlank())
                || (satTick.isSelected() && sat.getText().isBlank()) || (sunTick.isSelected() && sun.getText().isBlank())){
            
            Alert noEmployees = new Alert(Alert.AlertType.ERROR);
            noEmployees.setHeaderText("Please add the number of employees required per day under optional settings or untick the selected option.");
            noEmployees.showAndWait();        
        }
        else{                              
            Alert createShiftConfirmation = new Alert(Alert.AlertType.CONFIRMATION);
            createShiftConfirmation.setHeaderText("Are you sure you want to create shifts automatically for the selected period, employees and settings?");
            createShiftConfirmation.showAndWait();

            if(createShiftConfirmation.getResult().getText().equalsIgnoreCase("OK")){
                

                //set date variable as the first date in the selected shedule period
                 LocalDate date = scheduleFromDate.getValue();                                           
                 employeesSelected.addAll(selectedEmployeesTable.getItems());
                 
                 //for each day in the schedule period
                  for (int i=0; i < schedulePeriod; i++){
                                                                                   
                      //if any day falls on a Monday, reset the weekly assigned/allocated hours for an employee to 0.
                      if(date.getDayOfWeek().getValue()==1){
                                assignedHours1 = 0;
                                }
                   
                      //for each employee selected
                      for (Employee employee : employeesSelected){
                          
                         //get number of working shifts currently assigned on this day in order to meet demand metric of required number of employees on a day - under optional settings
                         numOfShiftsOnDay = DAO.getNumOfShiftsOnDay(date.format(formatter));
                        
                         
                         
                        if( ((date.getDayOfWeek().getValue()==1) && (((numOfShiftsOnDay < Integer.parseInt(mon.getText()))) || ((Integer.parseInt(mon.getText())==0)))) || 
                            ((date.getDayOfWeek().getValue()==2) && (((numOfShiftsOnDay < Integer.parseInt(tue.getText()))) || ((Integer.parseInt(tue.getText())==0)))) ||
                            ((date.getDayOfWeek().getValue()==3) && (((numOfShiftsOnDay < Integer.parseInt(wed.getText()))) || ((Integer.parseInt(wed.getText())==0)))) ||
                            ((date.getDayOfWeek().getValue()==4) && (((numOfShiftsOnDay < Integer.parseInt(thu.getText()))) || ((Integer.parseInt(thu.getText())==0)))) ||
                            ((date.getDayOfWeek().getValue()==5) && (((numOfShiftsOnDay < Integer.parseInt(fri.getText()))) || ((Integer.parseInt(fri.getText())==0)))) ||
                            ((date.getDayOfWeek().getValue()==6) && (((numOfShiftsOnDay < Integer.parseInt(sat.getText()))) || ((Integer.parseInt(sat.getText())==0)))) ||
                            ((date.getDayOfWeek().getValue()==7) && (((numOfShiftsOnDay < Integer.parseInt(sun.getText()))) || ((Integer.parseInt(sun.getText())==0))))){
                                                                                                      
                        
                        //set assigned/allocated hours count to 0  
                        assignedHours1=0;
                          
                        //get and store employee contract from database as we will need this for contract constraint checks
                        Contract contract = DAO.getContract(employee.getEmployeeContract());
                        
                        //store shift cost for each shift that will be created, based on the hourly rate in the current employee multiplied by the 
                        //duration of hours for the shift.
                        shiftCost = Double.parseDouble(df.format((DAO.getHourlyRate(employee.getEmployeeID())) * totalDuration));                                   
                                
                        //hard constraint - check that the current employee contract end date has not passed for this day in the projected schedule period
                        
                        if(!(date.isAfter(LocalDate.parse(contract.getContractEndDate())))){
                        //System.out.println("Contract end date check passed (line812)");                                               
                        //The following block of code then gets current number of working hours already assigned for the current employee, for the current week of current day
                        //in the loop

                            //first set variables for finding the current week in the chosen schedule period and setting the start and end dates for this week
                            LocalDate startOfWeek = date.with(DayOfWeek.MONDAY);
                            LocalDate endOfWeek = date.with(DayOfWeek.SUNDAY);
                            long weekPeriod = startOfWeek.until(endOfWeek, DAYS)+1;//sets period of days to iterate through to check for existing shifts
                                                       
                            LocalDate day = startOfWeek;
                                                                                    
                                //for each day of the first week in the projected schedule period
                                for (int a=0; a < weekPeriod; a++){                            

                                    //check if there are any existing shifts assigned
                                    if(DAO.checkEmployeeShift(employee.getEmployeeID(), day.format(formatter))==true){                                                                              
                                        
                                        Shift shift = DAO.getEmployeeShift(employee.getEmployeeID(), day.format(formatter));
                                        //check that this is a working shifts
                                        if(shift.getShiftType().equalsIgnoreCase("1")){
                                        
                                        //if a shift is assigned then get the duration of hours for that planned shift    
                                        LocalTime shiftStart = LocalTime.parse(shift.getShiftStart());
                                        LocalTime shiftEnd = LocalTime.parse(shift.getShiftEnd());
                                        int hours1 = Duration.ofHours(24).plus(Duration.between(shiftStart, shiftEnd)).toHoursPart();
                                        double minutes1 = Double.parseDouble(df.format((Duration.between(shiftStart, shiftEnd).toMinutesPart())*0.0166)); 
                                        double duration1 = hours1 + minutes1;
                                        
                                        double assignedHours2 = 0;

                                        //add the duration to a total assigned to the employee for that week of the schedule period.
                                        assignedHours2 = Double.sum(assignedHours2, duration1);   
                                        assignedHours1 = Double.sum(assignedHours1, assignedHours2); //passes the total number of hours currentl assigned for the week to assignedHours1 
                                        }
                                     }                                                                                                                                               
                                    //increment a day and continue the loop to get all assigned hours for that week 
                                    day = day.plusDays(1);
                                }                                      
                                //end of calculating working hours for the week     
                 
                            //hard constraint - now check if the contracted weekly hours for the employee has and will not been exceeded
                            if (!(Double.sum(assignedHours1, totalDuration) > Double.parseDouble(contract.getContractedHours()))){
                                //System.out.println("Contracted weekly hours not exceeded check passed (line 855)");
                                                                                             
                                //hard constraint (sick days, annual leave, etc) - check if the current employee has a shift or any time-off already allocated on 
                                //the current date of the projected schedule period and if does, then to skip this day. 
                                if(!(DAO.checkEmployeeShift(employee.getEmployeeID(), date.format(formatter))==true)){
                                          //System.out.println("Existing shift on this date check passed (line 860)");              
                                     /*hard constraint - the following block checks if employee has a shift booked the day before the current date as if does, will need to check the constraint 
                                     for minimum hours between shifts has not been exceeded                        
                                     */
                                     
                                     //check if a shift exists the day before this day as if does, will need to check if minimum hours between the last shift and the next will not be exceeded
                                     if(DAO.checkEmployeeShift(employee.getEmployeeID(), date.minusDays(1).format(formatter))==true){
                                         //System.out.println("Check shift exists the day before check passed (line 867)");
                                         //if there is a shift booked for the day before, then get the end time for it as well as the start time of the new shift to work out the hours inbetween
                                         Shift shift2 = DAO.getEmployeeShift(employee.getEmployeeID(), date.minusDays(1).format(formatter));
                                       //check if the shift is a working shift  
                                       if(shift2.getShiftType().equalsIgnoreCase("1")){
                                           
                                                                                   
                                         LocalTime shiftEnd = LocalTime.parse(shift2.getShiftEnd());
                                         LocalTime shiftStart = startTime;
                                         int hours2 = Duration.ofHours(24).plus(Duration.between(shiftEnd, shiftStart)).toHoursPart();
                                         double minutes2 = Double.parseDouble(df.format((Duration.between(shiftEnd, shiftStart).toMinutesPart())*0.0166));
                                         double duration2 = hours2 + minutes2;
                                                                                  
                                                                     
                                            //hard constraint - now check that minimum hours between shifts as stated in the contract has not been exceeded
                                            if(duration2 >= Double.parseDouble(contract.getMinHoursBetweenShifts())){                                           

                                                ////Now consider any soft constraints 

                                                //check if the current employees preferred days off 1 is on this date and if so then assign day off                               
                                                if(Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue()){
                                                    //System.out.println("Preferred day off 1 check passed(line 889) - assign day off");

                                                    //assign day off
                                                    DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                } 
                                                //check if the current employees preferred days off 2 is on this date and if so then assign day off 
                                                else if(Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue()){
                                                    //System.out.println("Preferred day off 2 check passed(line 896) - assign day off");

                                                    //assign day off
                                                    DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                }

                                               //before assigning a working shift check for consecutive working days before this date   
                                               else{ 
                                                    //System.out.println("Check consecutive working days (line 904)");
                                                   int consDays = Integer.parseInt(contract.getMaxConsWorkDays());
                                                   LocalDate startConsDays = date.minusDays(consDays); 
                                                   int consShifts = 0;

                                                   for (int b=0; b < consDays; b++){
                                                       
                                                    try{
                                                            Shift shift3 = DAO.getEmployeeShift(employee.getEmployeeID(), startConsDays.format(formatter));

                                                            if (shift3.getShiftType().equalsIgnoreCase("1")){
                                                                consShifts = consShifts + 1;
                                                            }                                                           
                                                        }
                                                    catch(NullPointerException s){
                                                            }
                                                    startConsDays = startConsDays.plusDays(1);
                                                   }
                                                   //System.out.println("cons loop 1: "+employee.getEmployeeName()+" "+ date +" "+ consShifts);                                                  

                                                  //check if maximum consecutive working days has been reached and if so, assign a day off 
                                                  if (consShifts >= Integer.parseInt(contract.getMaxConsWorkDays())){
                                                      //System.out.println("Consecutive working days check failed (line 931) - assign day off");

                                                        //assign day off
                                                        DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                  }                                  
                                                  else {
                                                      //System.out.println("Consecutive working days check passed(line 937) - assign shift");
                                                    //Or finally, assign the working shift
                                                    DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                                                   }                                                                                        
                                                }
                                           }//if next shift starts before the minimum hours required between shifts
                                            else{
                                                //System.out.println("Minimum hours between shifts check failed (line 944)");
                                                //assign day off
                                                DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                            }                                   
                                      }
                                       else{
                                           //System.out.println("Existing shift is not a working shift (line 950)");
                                           
                                           //check if the current employees preferred days off 1 is on this date and if so then assign day off                               
                                                if(Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue()){
                                                    //System.out.println("Preferred day off 1 check passed(line 954) - assign day off");

                                                    //assign day off
                                                    DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                } 
                                                //check if the current employees preferred days off 2 is on this date and if so then assign day off 
                                                else if(Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue()){
                                                    //System.out.println("Preferred day off 2 check passed(line 961) - assign day off");

                                                    //assign day off
                                                    DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                }
                                                else {
                                                      //System.out.println("Consecutive working days check passed(line 967) - assign shift");
                                                    //Or finally, assign the working shift
                                                    DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                                                   }                                          
                                       }
                                         
                                    }//if the employee did not have a shift the day before the current date then can ignore checking min hours between shifts and 
                                     //continue the remainder of the loop - soft constraints
                                       
                                     
                                    //check if the current employees preferred days off is on this date and if so then assign the days off, else assign a working shift                              
                                    else { 
                                         //System.out.println("Check shift exists the day before check failed (line 979)");
                                         //check if the current employees preferred days off1 is on this date and if so then assign day off 
                                         if (Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue()){
                                             //System.out.println("Preferred day off 1 check passed(line 982) - assign day off");
                                                 //assign day off
                                                 DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                         } 
                                         //check if the current employees preferred days off2 is on this date and if so then assign day off 
                                         else if(Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue()){
                                                //System.out.println("Preferred day off 2 check passed(line 988) - assign day off");
                                                 //assign day off
                                                 DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                         }                              
                                         //before assaigning a shift, check if maximum consecutive days has been reached
                                         else {
                                             //System.out.println("Check consecutive working days (line 994)");
                                                int consDays2 = Integer.parseInt(contract.getMaxConsWorkDays());
                                                LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                int consShifts2 = 0;

                                                for (int c=0; c < consDays2; c++){
                                                    
                                                    try{                                                   
                                                            Shift shift4 = DAO.getEmployeeShift(employee.getEmployeeID(), startConsDays2.format(formatter));
                                                            if (shift4.getShiftType().equalsIgnoreCase("1")){//check if this is a working shift
                                                                consShifts2 = consShifts2 + 1;
                                                            }
                                                            //System.out.println("Actual Date in schedule: " + date);
                                                            //System.out.println("cons loop 2: "+employee.getEmployeeName()+" "+ startConsDays2 +" "+ consShifts2);
                                                        }

                                                    catch(NullPointerException s){

                                                            }
                                                    startConsDays2 = startConsDays2.plusDays(1);
                                                }     
                                                                                                                                                                                        
                                               //check if maximum consecutive working days has been reached and if so, assign a day off 
                                               if (consShifts2 >= Integer.parseInt(contract.getMaxConsWorkDays())){
                                                   //System.out.println("Check consecutive working days check failed(line 1018) - assign day off");                                                                                            
                                                     //assign day off
                                                     DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                               }                                  
                                               else {
                                                   //System.out.println("Check consecutive working days check passed(line 1023) - assign working shift"); 
                                                 //Or finally, assign the working shift
                                                 DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                                                }
                                            }
                                        }                           
                                }    
                            }
                            else{
                                //System.out.println("Contracted weekly hours has been exceeded (line 1032)");
                                //hard constraint (sick days, annual leave, etc) - check if the current employee has a shift or any time-off already allocated on 
                                //the current date of the projected schedule period and if does, then to skip this day. 
                                if(!(DAO.checkEmployeeShift(employee.getEmployeeID(), date.format(formatter))==true)){
                                    //System.out.println("Check for any pre-booked shifts passed (line 1036)");
                                    //check if the current employees preferred days off1 is on this date and if so then assign day off 
                                    if (Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue()){
                                        //System.out.println("Preferred day off 1 check passed(line 1039) - assign day off");
                                        //assign day off
                                        DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                    }
                                    //check if the current employees preferred days off2 is on this date and if so then assign day off 
                                    else if(Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue()){                                   
                                        //System.out.println("Preferred day off 2 check passed(line 1045) - assign day off");
                                        //assign day off
                                        DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                    }
                                    else{
                                        //System.out.println("Assign day off (line 1050)) - assign day off");
                                        //assign day off
                                        DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                    }
                                }                               
                            }                                             
                         }
                      }
                        else{
                            //assign day off
                            DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                        }
                        
                    } 
                  
                    //increment a day in the schedule period
                    //System.out.println("Increment a day in the schedule loop from: " + date + " to " + date.plusDays(1));
                    date = date.plusDays(1);
                    
                } //complete the full loop for the remaining days of the schedule period
                  //System.out.println("Finished loop");
                  Stage autoShedule = (Stage) this.autoShiftCancelButton.getScene().getWindow();
                  autoShedule.close();

                  refreshCalendar();//update the calendar                 
            }            
        }             
    }



/*
    *Same as 1, 2, and 3, however after hard constraints are considered, system prioritises any specified 
    *numbers of employees required on any day entered under optional settings. So if on Monday, 7 staff are 
    *required then this will take precedence over prefered days off and consecutive working days (or soft constraints).
    *If no employees are set on a particular day under optional settings then the system reverts to prioritising soft constraints.
    *Noticed that this can be unfair on the staff at the top of the database as allocates those staff first while 
    *later staff could lose out on hours if day limit is reached before they are reached in the loops. To solve this 
    *could do a check on soft constraints again before assigning the shift for days which have set employee numbers
    *or probably more efficient to check staff that do not have preferred days off on these days instead.
    *
    */
    @FXML
    private void automatedShifts5() throws ClassNotFoundException, SQLException, ParseException{
        
        //variables for the start and end dates of chosen schedule period
        LocalDate startDate = scheduleFromDate.getValue();
        LocalDate endDate = scheduleToDate.getValue(); 
        
        //variable for the selected shift pattern
        int shiftPattern = shiftPatternComboBox.getSelectionModel().getSelectedIndex()+1;
        
        //variable for the selected shift type
        int shiftType =  shiftTypeComboBox.getSelectionModel().getSelectedIndex()+1;
        
        //start and end times for chosen shift period
        LocalTime startTime = LocalTime.of(Integer.parseInt(startTimeHours.getSelectionModel().getSelectedItem()), Integer.parseInt(startTimeMinutes.getSelectionModel().getSelectedItem()));
        LocalTime finishTime = LocalTime.of(Integer.parseInt(finishTimeHours.getSelectionModel().getSelectedItem()), Integer.parseInt(finishTimeMinutes.getSelectionModel().getSelectedItem()));
        
        //variable for days between start and end dates for the selected schedule period
        long schedulePeriod = ChronoUnit.DAYS.between(startDate, endDate)+1;
        
        //variable for total number of hours in a assigned/selected shift
        int totalHours = Duration.ofHours(24).plus(Duration.between(startTime, finishTime)).toHoursPart();
           
        //variable for the minutes part of a assigned/selected shift. For example 8 hours and 15 minutes. This value would be 15 minutes.
        double totalMinutes = Double.parseDouble(df.format((Duration.between(startTime, finishTime).toMinutesPart())*0.0166));        
        
        //variable for total duration of a assigned shift
        double totalDuration = totalHours + totalMinutes;
        
        //variable shift cost value
        double shiftCost;
        
        //variable for holding the number of hours assigned to an employee in a week to evaluate for not exceeding the weekly contracted hours.
        double assignedHours1;
       
        
        //variable for holding number of shifts on a day to meet ideal number of employees required on a day constraint.
        int numOfShiftsOnDay;
        
        double hoursRequired = 0; //required hours by shift planner
        double maxAvailableHours = 0.0; //max available hours based on slected staff and their contrcated hours
        double averageEmployeesPossible = 0; //average of employeess possible per day in a week based on available hours
        double remainingEmployees = 0;//remainder from the average result to add onto random days
        int weekdays = 7;
        
       
        //validation check the user has selected at least one employee    
        if(selectedEmployeesTable.getItems().isEmpty()){
            
            Alert noSelection = new Alert(Alert.AlertType.ERROR);
            noSelection.setHeaderText("Please choose an employee or employees to allocate shifts");
            noSelection.showAndWait();
        }
        //validation check for ensuring only numbers are entered into the staff required per day under optional settings
        else if((allDaysTick.isSelected() && !allDays.getText().matches("\\d*")) || (monTick.isSelected() && !mon.getText().matches("\\d*")) || (tueTick.isSelected() && !tue.getText().matches("\\d*"))
                || (wedTick.isSelected() && !wed.getText().matches("\\d*")) || (thuTick.isSelected() && !thu.getText().matches("\\d*")) || (friTick.isSelected() && !fri.getText().matches("\\d*"))
                || (satTick.isSelected() && !sat.getText().matches("\\d*")) || (sunTick.isSelected() && !sun.getText().matches("\\d*"))){
            
            Alert numbersOnly = new Alert(Alert.AlertType.ERROR);
            numbersOnly.setHeaderText("Please use whole numbers only for employees required per day under Optional Settings.");
            numbersOnly.showAndWait();
            
        }
        //validation check for ensuring number of staff required per day under optional setiings, is not blank/empty.
        else if((allDaysTick.isSelected() && allDays.getText().isBlank()) || (monTick.isSelected() && mon.getText().isBlank()) || (tueTick.isSelected() && tue.getText().isBlank())
                || (wedTick.isSelected() && wed.getText().isBlank()) || (thuTick.isSelected() && thu.getText().isBlank()) || (friTick.isSelected() && fri.getText().isBlank())
                || (satTick.isSelected() && sat.getText().isBlank()) || (sunTick.isSelected() && sun.getText().isBlank())){
            
            Alert noEmployees = new Alert(Alert.AlertType.ERROR);
            noEmployees.setHeaderText("Please add the number of employees required per day under Optional Settings or untick the selected option.");
            noEmployees.showAndWait();        
        }
        else if((allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>selectedEmployeesTable.getItems().size()) || 
                (monTick.isSelected() && Integer.parseInt(mon.getText())>selectedEmployeesTable.getItems().size()) || 
                (tueTick.isSelected() && Integer.parseInt(tue.getText())>selectedEmployeesTable.getItems().size()) ||
                (wedTick.isSelected() && Integer.parseInt(wed.getText())>selectedEmployeesTable.getItems().size()) || 
                (thuTick.isSelected() && Integer.parseInt(thu.getText())>selectedEmployeesTable.getItems().size()) || 
                (friTick.isSelected() && Integer.parseInt(fri.getText())>selectedEmployeesTable.getItems().size()) ||
                (satTick.isSelected() && Integer.parseInt(sat.getText())>selectedEmployeesTable.getItems().size()) || 
                (sunTick.isSelected() && Integer.parseInt(sun.getText())>selectedEmployeesTable.getItems().size())){
            
            Alert tooManyEmployees = new Alert(Alert.AlertType.ERROR);
            tooManyEmployees.setHeaderText("The required number of employees per day must be lower than the number of employees selected/available ("+selectedEmployeesTable.getItems().size()+")");
            tooManyEmployees.showAndWait();   
            
        }        
        else{                              
            Alert createShiftConfirmation = new Alert(Alert.AlertType.CONFIRMATION);
            createShiftConfirmation.setHeaderText("Are you sure you want to create shifts automatically for the selected period, employees and settings?");
            createShiftConfirmation.showAndWait();

            if(createShiftConfirmation.getResult().getText().equalsIgnoreCase("OK")){
                                        
                    LocalDate scheduleDate = scheduleFromDate.getValue(); //set date variable as the first date in the selected shedule period                
                    ArrayList<LocalDate> dates = new ArrayList<>();//these are priority dates if selected by the shift planner under optional settings unless all are selected
                    ArrayList<LocalDate> dates2 = new ArrayList<>();//these will be randomised and less prioritised                                                               
                    
                    employeesSelected.addAll(selectedEmployeesTable.getItems()); //get the employees and add to an ArrayList                 
                    Collections.shuffle(employeesSelected);//randomise order of employees so a fair distribution of shifts can be acheived                 
                    employeesSelected2.addAll(selectedEmployeesTable.getItems()); //a copy of the list to be shuffled later and used in other search loops  

                    //retreive the maximum available hours for a week from the staff selected and their contracted hours
                    for (Employee employee : employeesSelected){
                             maxAvailableHours = maxAvailableHours + DAO.getContractedHours(Integer.parseInt(employee.getEmployeeID()));                          
                       }

                    //get the average number of employees available per day in a week from the staff available and using the duration of each shift required
                    averageEmployeesPossible = Math.round((maxAvailableHours/7)/totalDuration);                            
                    //retreive total of lost remainders during rounding numbers which may total more than one employee, which will need to be added onto a random day
                    remainingEmployees = Math.round((maxAvailableHours-((averageEmployeesPossible*7)*totalDuration))/totalDuration);

                    int employees = (int) averageEmployeesPossible;//converted rounded double values to integers to wok better with parsing textfields later
                    int remainingEmps = (int) remainingEmployees;//converted double values to integers to wok better with parsing textfields later
                 
                 
                 
                //if no optional days (including all days tickbox) are selected (ticked), then set all days in the selected schedule to be allocated to the closest as possible, 
                //an average number of employees per day. Any remaining employees (from rounding averages) will be addedd randomly to random days.
          
                if(!allDaysTick.isSelected() && !monTick.isSelected() && !tueTick.isSelected() && !wedTick.isSelected() && !thuTick.isSelected() &&
                         !friTick.isSelected() && !satTick.isSelected() && !sunTick.isSelected()){                                        
                    
                   
                    monTick.setSelected(true); tueTick.setSelected(true); wedTick.setSelected(true); thuTick.setSelected(true); friTick.setSelected(true); satTick.setSelected(true);
                    sunTick.setSelected(true);                                        
                    ObservableList<TextField> dayTextFields = FXCollections.observableArrayList(mon, tue, wed, thu, fri, sat, sun);//to store tickboxes
                    Collections.shuffle(dayTextFields);//randomise order of text fields
                    
                    for (TextField day : dayTextFields){                        
                        if (remainingEmps>0){
                            day.setText(String.valueOf(employees+1));//add each remainder of employees on a random day
                            remainingEmps = remainingEmps-1;
                        }
                        else{
                            day.setText(String.valueOf(employees));//else assign average employees on remaining random days in the week
                        }
                        
                    }                    
                    for (int i=0; i < schedulePeriod; i++){                        
                        dates.add(scheduleDate);
                        scheduleDate = scheduleDate.plusDays(1);
                    }
                    Collections.shuffle(dates);
                }
                
                //if all days is selected then check if the hours required are over the hours available and if so then average the hours between all days
                else if(allDaysTick.isSelected()){  
                    
                    //get hours requested
                    hoursRequired = (Double.parseDouble(allDays.getText())*7)*totalDuration;                  
                    
                    if(Integer.parseInt(allDays.getText())==0){
                        
                        allDaysTick.setSelected(false); 
                        monTick.setSelected(true); tueTick.setSelected(true); wedTick.setSelected(true); thuTick.setSelected(true); friTick.setSelected(true); satTick.setSelected(true);
                        sunTick.setSelected(true);
                        mon.setText("0"); tue.setText("0"); wed.setText("0"); thu.setText("0"); fri.setText("0"); sat.setText("0"); sun.setText("0"); 
                        for (int i=0; i < schedulePeriod; i++){                        
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                        }                     
                    }               
                    
                    else if(hoursRequired>=maxAvailableHours){
                        allDaysTick.setSelected(false);                        
                        //will use the days to average the shift allocations 
                        monTick.setSelected(true); tueTick.setSelected(true); wedTick.setSelected(true); thuTick.setSelected(true); friTick.setSelected(true); satTick.setSelected(true);
                        sunTick.setSelected(true);                                        
                        ObservableList<TextField> dayTextFields = FXCollections.observableArrayList(mon, tue, wed, thu, fri, sat, sun);//to iterate textfields
                        Collections.shuffle(dayTextFields);//randomise order of text fields
                                                
                        for (TextField day : dayTextFields){
                            
                                day.setText(String.valueOf(employees));// assign average employees on random days in the week
                            
                        }
                        for (int i=0; i < schedulePeriod; i++){                        
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                        }
                        Collections.shuffle(dates);                        
                    }                    
                    //For all days selected tickbox - evenly ditributes shifts using an average                 
                    else{                        
                        allDaysTick.setSelected(false);                        
                        //will use the days to average the shift allocations 
                        monTick.setSelected(true); tueTick.setSelected(true); wedTick.setSelected(true); thuTick.setSelected(true); friTick.setSelected(true); satTick.setSelected(true);
                        sunTick.setSelected(true);                                        
                        ObservableList<TextField> dayTextFields = FXCollections.observableArrayList(mon, tue, wed, thu, fri, sat, sun);//to iterate textfields
                        Collections.shuffle(dayTextFields);//randomise order of text fields                                                                    
                                                
                            for (TextField day : dayTextFields){                        

                                day.setText(allDays.getText());//else assign average employees on remaining random days in the week                                        
                            }                    
                            for (int i=0; i < schedulePeriod; i++){                        
                                dates.add(scheduleDate);
                                scheduleDate = scheduleDate.plusDays(1);
                            }
                            Collections.shuffle(dates);                        
                    }                    
                 }
                //if any of the individual days are selected                                  
                else if(monTick.isSelected() || tueTick.isSelected() || wedTick.isSelected() || thuTick.isSelected() ||
                         friTick.isSelected() || satTick.isSelected() || sunTick.isSelected()){  
                       System.out.println("Entered at line 1672");
                    
                    int employeesRequired = 0;
                    int sublist = 0;//index counter for randomising (later) dates which are not selected under optional settings 
                    hoursRequired = 0;
                    //this loop will ensure that any days selected under optional settings by the shift planner will be prioritised for allocating shifts against non-selected days
     
                       
                    if (monTick.isSelected() && Integer.parseInt(mon.getText())>0){
                        
                             hoursRequired = hoursRequired + Integer.parseInt(mon.getText())*totalDuration;;
                                employeesRequired = employeesRequired + Integer.parseInt(mon.getText());
                    }
                    if (tueTick.isSelected() && Integer.parseInt(tue.getText())>0){
                        
                             hoursRequired = hoursRequired + Integer.parseInt(tue.getText())*totalDuration;;
                                employeesRequired = employeesRequired + Integer.parseInt(tue.getText());
                    }
                    if (wedTick.isSelected() && Integer.parseInt(wed.getText())>0){
                        
                             hoursRequired = hoursRequired + Integer.parseInt(wed.getText())*totalDuration;;
                                employeesRequired = employeesRequired + Integer.parseInt(wed.getText());
                    }
                    if (thuTick.isSelected() && Integer.parseInt(thu.getText())>0){
                        
                             hoursRequired = hoursRequired + Integer.parseInt(thu.getText())*totalDuration;;
                                employeesRequired = employeesRequired + Integer.parseInt(thu.getText());
                    }
                    if (friTick.isSelected() && Integer.parseInt(fri.getText())>0){
                        
                             hoursRequired = hoursRequired + Integer.parseInt(fri.getText())*totalDuration;;
                                employeesRequired = employeesRequired + Integer.parseInt(fri.getText());
                    }
                    if (satTick.isSelected() && Integer.parseInt(sat.getText())>0){
                        
                             hoursRequired = hoursRequired + Integer.parseInt(sat.getText())*totalDuration;;
                                employeesRequired = employeesRequired + Integer.parseInt(sat.getText());
                    }
                    if (sunTick.isSelected() && Integer.parseInt(sun.getText())>0){
                        
                             hoursRequired = hoursRequired + Integer.parseInt(sun.getText())*totalDuration;;
                                employeesRequired = employeesRequired + Integer.parseInt(sun.getText());
                    }
                     System.out.println("line 1715 hours required = "+hoursRequired);   
                     System.out.println("line 1716 hours required = "+employeesRequired);
                        
                    for (int i=0; i<schedulePeriod; i++){
                        
                        if (scheduleDate.getDayOfWeek().getValue()==1 && (monTick.isSelected() && Integer.parseInt(mon.getText())>0)){
                            
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1;                                                        
                        }
                        else if(scheduleDate.getDayOfWeek().getValue()==2 && (tueTick.isSelected() && Integer.parseInt(tue.getText())>0)){
                            
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1; 
                        }  
                        else if(scheduleDate.getDayOfWeek().getValue()==3 && (wedTick.isSelected() && Integer.parseInt(wed.getText())>0)){
                            
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1; 
                        }
                        else if(scheduleDate.getDayOfWeek().getValue()==4 && (thuTick.isSelected() && Integer.parseInt(thu.getText())>0)){
                            
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1; 
                        }
                        else if(scheduleDate.getDayOfWeek().getValue()==5 && (friTick.isSelected() && Integer.parseInt(fri.getText())>0)){
                            
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1; 
                        }
                        else if(scheduleDate.getDayOfWeek().getValue()==6 && (satTick.isSelected() && Integer.parseInt(sat.getText())>0)){
                            
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1; 
                        }
                        else if(scheduleDate.getDayOfWeek().getValue()==7 && (sunTick.isSelected() && Integer.parseInt(sun.getText())>0)){
                                                        
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1; 
                        }
                        else{
                            dates2.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                        }
                        
                    }                    
                    Collections.shuffle(dates);//randomise these priority dates first 
                    
                    if(dates2.isEmpty()==false){
                        dates.addAll(dates2); //then add the lesser priority dates                                                                 
                        Collections.shuffle(dates.subList(sublist, dates.size()));//finally randomise the lesser priority dates from index sublist
                    }
                    
                    //if hours required are higher than those available then we need to adjust (by reduction) all 
                    //of the required employees set by the shift planner, proportionally down to below the available hours.  
                    if (hoursRequired>=maxAvailableHours){
                        System.out.println("line 1778 hours required = "+hoursRequired);
                        System.out.println("line 1779 hours available = "+maxAvailableHours);
                        
                       double multiplier = maxAvailableHours/employeesRequired;
                       double newValue = 0;                       
                       int intNewValue = 0; 
                       int totalAllocated = 0;
                       double remainder = 0;
                       int intRemainder = 0;
                       int daysLeft = 7; //remaining days will be those that are not selected/ticket
                       
                       int monOldValue = 0;
                       int tueOldValue = 0;
                       int wedOldValue = 0;
                       int thuOldValue = 0;
                       int friOldValue = 0;
                       int satOldValue = 0;
                       int sunOldValue = 0;
                       
                       ObservableList<TextField> dayTextFields = FXCollections.observableArrayList(mon, tue, wed, thu, fri, sat, sun);//to iterate textfields
                       ObservableList<TextField> priorityDayTextFields = FXCollections.observableArrayList();//to record priority days
                       
                           for(TextField day : dayTextFields){ 
                                  
                               if (day.isDisabled()==false && Integer.parseInt(day.getText())>0){
                                   
                                   if(day.equals(mon)){
                                       monOldValue = Integer.parseInt(mon.getText());
                                       newValue = (Integer.parseInt(mon.getText())*multiplier)/totalDuration;
                                       intNewValue = (int) newValue;
                                       mon.setText(String.valueOf(intNewValue));
                                       totalAllocated = totalAllocated + intNewValue;
                                       daysLeft = daysLeft-1;
                                       priorityDayTextFields.add(mon);

                                   }
                                   else if(day.equals(tue)){
                                       tueOldValue = Integer.parseInt(tue.getText());
                                       newValue = (Integer.parseInt(tue.getText())*multiplier)/totalDuration;
                                       intNewValue = (int) newValue;
                                       tue.setText(String.valueOf(intNewValue));
                                       totalAllocated = totalAllocated + intNewValue;
                                       daysLeft = daysLeft-1;
                                       priorityDayTextFields.add(tue);

                                   }
                                   else if(day.equals(wed)){
                                      wedOldValue = Integer.parseInt(wed.getText());
                                      newValue = (Integer.parseInt(wed.getText())*multiplier)/totalDuration;
                                       intNewValue = (int) newValue;
                                       wed.setText(String.valueOf(intNewValue));
                                       totalAllocated = totalAllocated + intNewValue;
                                       daysLeft = daysLeft-1;
                                       priorityDayTextFields.add(wed);

                                   }
                                   else if(day.equals(thu)){
                                       thuOldValue = Integer.parseInt(thu.getText());
                                       newValue = (Integer.parseInt(thu.getText())*multiplier)/totalDuration;
                                       intNewValue = (int) newValue;
                                       thu.setText(String.valueOf(intNewValue));
                                       totalAllocated = totalAllocated + intNewValue;
                                       daysLeft = daysLeft-1;
                                       priorityDayTextFields.add(thu);

                                   }
                                   else if(day.equals(fri)){
                                       friOldValue = Integer.parseInt(fri.getText());
                                       newValue = (Integer.parseInt(fri.getText())*multiplier)/totalDuration;
                                       intNewValue = (int) newValue;
                                       fri.setText(String.valueOf(intNewValue));
                                       totalAllocated = totalAllocated + intNewValue;
                                       daysLeft = daysLeft-1;
                                       priorityDayTextFields.add(fri);

                                   }
                                   else if(day.equals(sat)){
                                       satOldValue = Integer.parseInt(sat.getText());
                                       newValue = (Integer.parseInt(sat.getText())*multiplier)/totalDuration;
                                       intNewValue = (int) newValue;
                                       sat.setText(String.valueOf(intNewValue));
                                       totalAllocated = totalAllocated + intNewValue;
                                       daysLeft = daysLeft-1;
                                       priorityDayTextFields.add(sat);

                                   }
                                   else if(day.equals(sun)){
                                       sunOldValue = Integer.parseInt(sun.getText());
                                       newValue = (Integer.parseInt(sun.getText())*multiplier)/totalDuration;
                                       intNewValue = (int) newValue;
                                       sun.setText(String.valueOf(intNewValue));
                                       totalAllocated = totalAllocated + intNewValue;
                                       daysLeft = daysLeft-1;
                                       priorityDayTextFields.add(sun);

                                   }                                                                                                                                                                                                                       
                                    
                               } 
                               else if(day.isDisabled()==false && Integer.parseInt(day.getText())==0){
                                   daysLeft = daysLeft-1;
                               }
                          }
                           
                          //the following block will give extra days from remainder of hours to priority set days
                          remainder = Math.round((maxAvailableHours-(totalAllocated*totalDuration))/totalDuration);
                          intRemainder = (int) remainder;                                                      
                          Collections.shuffle(priorityDayTextFields);
                          
                          System.out.println("line 1849 intRemainder = "+intRemainder);
                          if(intRemainder>0){
                             totalAllocated = totalAllocated + intRemainder;
                              for (TextField day : priorityDayTextFields){
                                                                        
                                    if(day.equals(mon) && Integer.parseInt(mon.getText()) < monOldValue){
                                      if(intRemainder>0){
                                        mon.setText(String.valueOf(Integer.parseInt(mon.getText())+1));
                                        intRemainder = intRemainder -1;
                                      }
                                    }
                                    else if(day.equals(tue) && Integer.parseInt(tue.getText()) < tueOldValue){
                                        if(intRemainder>0){
                                        tue.setText(String.valueOf(Integer.parseInt(tue.getText())+1));
                                        intRemainder = intRemainder -1;
                                      }
                                    }
                                    else if(day.equals(wed) && Integer.parseInt(wed.getText()) < wedOldValue){
                                        if(intRemainder>0){
                                        wed.setText(String.valueOf(Integer.parseInt(wed.getText())+1));
                                        intRemainder = intRemainder -1;
                                      }
                                    }
                                    else if(day.equals(thu) && Integer.parseInt(thu.getText()) < thuOldValue){
                                        
                                        if(intRemainder>0){
                                        thu.setText(String.valueOf(Integer.parseInt(thu.getText())+1));
                                        intRemainder = intRemainder -1;
                                      }
                                    }
                                    else if(day.equals(fri) && Integer.parseInt(fri.getText()) < friOldValue){
                                        
                                        if(intRemainder>0){
                                        fri.setText(String.valueOf(Integer.parseInt(fri.getText())+1));
                                        intRemainder = intRemainder -1;
                                      }
                                    }
                                    else if(day.equals(sat) && Integer.parseInt(sat.getText()) < satOldValue){
                                        
                                        if(intRemainder>0){
                                        sat.setText(String.valueOf(Integer.parseInt(sat.getText())+1));
                                        intRemainder = intRemainder -1;
                                      }
                                    }
                                    else if(day.equals(sun) && Integer.parseInt(sun.getText()) < sunOldValue){
                                       if(intRemainder>0){
                                        sun.setText(String.valueOf(Integer.parseInt(sun.getText())+1));
                                        intRemainder = intRemainder -1;
                                      }
                                    }                                    
                                }
                          }

                         Collections.shuffle(dayTextFields);                         
                         if(intRemainder>0){
                           //now for the days which are disabled - set an even average on these days only
                            if(daysLeft>0){
                                totalAllocated = totalAllocated + intRemainder;
                                for(TextField day : dayTextFields){                                                                        
                                         
                                         if (day.equals(mon)){
                                            if(intRemainder>0){ 
                                             monTick.setDisable(false);
                                             mon.setDisable(false);
                                             mon.setText(String.valueOf(0));
                                             mon.setText(String.valueOf(Integer.parseInt(mon.getText())+1));                                             
                                             intRemainder = intRemainder -1;
                                            }
                                         }
                                         else if(day.equals(tue)){
                                             if(intRemainder>0){
                                             tueTick.setDisable(false);
                                             tue.setDisable(false);
                                             tue.setText(String.valueOf(0));
                                             tue.setText(String.valueOf(Integer.parseInt(tue.getText())+1));
                                             intRemainder = intRemainder -1;
                                            }
                                         }
                                         else if(day.equals(wed)){
                                             if(intRemainder>0){
                                             wedTick.setDisable(false);
                                             wed.setDisable(false);
                                             wed.setText(String.valueOf(0));
                                             wed.setText(String.valueOf(Integer.parseInt(wed.getText())+1));
                                             intRemainder = intRemainder -1;
                                            }
                                         }
                                         else if(day.equals(thu)){
                                             if(intRemainder>0){
                                             thuTick.setDisable(false);
                                             thu.setDisable(false);
                                             thu.setText(String.valueOf(0));
                                             thu.setText(String.valueOf(Integer.parseInt(thu.getText())+1));
                                             intRemainder = intRemainder -1;
                                            }
                                         }
                                         else if(day.equals(fri)){
                                             if(intRemainder>0){
                                             friTick.setDisable(false);
                                             fri.setDisable(false);
                                             fri.setText(String.valueOf(0));
                                             fri.setText(String.valueOf(Integer.parseInt(fri.getText())+1));
                                             intRemainder = intRemainder -1;
                                            }
                                         }
                                         else if(day.equals(sat)){
                                             if(intRemainder>0){
                                             satTick.setDisable(false);
                                             sat.setDisable(false);
                                             sat.setText(String.valueOf(0));
                                             sat.setText(String.valueOf(Integer.parseInt(sat.getText())+1));
                                             intRemainder = intRemainder -1;
                                            }
                                         }
                                         else if(day.equals(sun)){
                                             if(intRemainder>0){
                                             sunTick.setDisable(false);
                                             sun.setDisable(false);
                                             sun.setText(String.valueOf(0));
                                             sun.setText(String.valueOf(Integer.parseInt(sun.getText())+1));
                                             intRemainder = intRemainder -1;
                                            }
                                         }                                                                                                                                                
                                }
                           }
                        }
                         
                        double remainder2 = 0;
                        int intRemainder2 = 0;

                        remainder2 = Math.round((maxAvailableHours-(totalAllocated*totalDuration))/totalDuration);
                        intRemainder2 = (int) remainder2;
                        
                        if (intRemainder2>0){                                                                                                        
                            System.out.println("line 2019 - remainder2 = "+intRemainder2);
                                for (TextField day : priorityDayTextFields){

                                    if(intRemainder2>0){ 
                                        if (intRemainder2>0){ 
                                         day.setText(String.valueOf(Integer.parseInt(day.getText())+1));
                                         intRemainder2 = intRemainder2-1;
                                        }
                                    }                                        
                                }                                         

                            if (intRemainder2>0){
                                System.out.println("line 2031 - remainder2 = "+intRemainder2);
                                for(TextField day : dayTextFields){ 

                                  if(intRemainder2>0){  

                                        day.setText(String.valueOf(Integer.parseInt(day.getText())+1));
                                        intRemainder2 = intRemainder2-1;                                                                              
                                }
                              }
                            }
                        }                                               
                     }                  
                }
                System.out.println("mon = "+mon.getText());
                System.out.println("tue = "+tue.getText());
                System.out.println("wed = "+wed.getText());
                System.out.println("thu = "+thu.getText());
                System.out.println("fri = "+fri.getText());
                System.out.println("sat = "+sat.getText());
                System.out.println("sun = "+sun.getText());
                                             
                            
                //for each day in the schedule period
                //for (int i=0; i < schedulePeriod; i++){
                for (LocalDate date : dates){     
                    Collections.shuffle(employeesSelected);//randomise employees per day
                                                                
                      //for each employee selected for the projected schedule period  
                      for (Employee employee : employeesSelected){
                          
                       if(shiftType>1){  
                           
                            DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, shiftType, 0);
                        }
                          
                        //get number of working shifts currently assigned on this day
                        numOfShiftsOnDay = DAO.getNumOfShiftsOnDay(date.format(formatter));   
                          
                        //set weekly assigned/allocated hours counter to 0  
                        assignedHours1=0;                                               
                        
                        //get and store employee contract from database as we will need this for contract constraint checks
                        Contract contract = DAO.getContract(employee.getEmployeeContract());
                        
                        //store shift cost for each shift that will be created, based on the hourly rate from the employee contract multiplied by the 
                        //duration of hours for the selected shift. This figure will be used at the point of assigning a shift.
                        shiftCost = Double.parseDouble(df.format((DAO.getHourlyRate(employee.getEmployeeID())) * totalDuration));                                   
                                
                        //hard constraint - check that the current employee contract end date has not passed the current day in the schedule period                     
                        if(!(date.isAfter(LocalDate.parse(contract.getContractEndDate())))){
                                                                    
                        /*The following block of code then gets current number of working hours already assigned for the current employee, for the current week of current day
                        *of the projected schedule period.
                        */
                            //first set variables for finding the current whole week (mon-sun)in the chosen schedule period and setting the start and end dates for this week
                            LocalDate startOfWeek = date.with(DayOfWeek.MONDAY);
                            LocalDate endOfWeek = date.with(DayOfWeek.SUNDAY);
                            //sets period of days to iterate through to check for existing shifts
                            long weekPeriod = startOfWeek.until(endOfWeek, DAYS)+1;
                                                       
                            LocalDate day = startOfWeek;
                                                                                    
                                //for each day of the first week in the projected schedule period
                                for (int a=0; a < weekPeriod; a++){                            

                                    //check if there are any existing shifts assigned
                                    if(DAO.checkEmployeeShift(employee.getEmployeeID(), day.format(formatter))==true){                                                                              
                                        
                                        //get the shift if it exists
                                        Shift shift = DAO.getEmployeeShift(employee.getEmployeeID(), day.format(formatter));
                                        
                                        //then check that this is a working shift using the shift type
                                        if(shift.getShiftType().equalsIgnoreCase("1")){
                                        
                                        //if working shift then get the duration of hours and minutes for that shift    
                                        LocalTime shiftStart = LocalTime.parse(shift.getShiftStart());
                                        LocalTime shiftEnd = LocalTime.parse(shift.getShiftEnd());
                                        int hours1 = Duration.ofHours(24).plus(Duration.between(shiftStart, shiftEnd)).toHoursPart();
                                        double minutes1 = Double.parseDouble(df.format((Duration.between(shiftStart, shiftEnd).toMinutesPart())*0.0166)); 
                                        double duration1 = hours1 + minutes1;
                                        //set a variable for the day to 0 to store this duration
                                        double assignedHours2 = 0;

                                        //adds the duration to the day variable 
                                        assignedHours2 = Double.sum(assignedHours2, duration1);
                                        
                                        //passes the duration to a running total for the week
                                        assignedHours1 = Double.sum(assignedHours1, assignedHours2);  
                                        }
                                     }                                                                                                                                               
                                    //increment a day and continue the loop to get all assigned hours for that week 
                                    day = day.plusDays(1);
                                }//end of calculating working hours for the week                                      
                                                      
                            //hard constraint - now ensures the contracted weekly hours for the current employee will not been exceeded - if exceeded then will assign day off
                            if (!(Double.sum(assignedHours1, totalDuration) > Double.parseDouble(contract.getContractedHours()))){                                
                                                                                             
                                /*hard constraint (sick days, annual leave, etc) - check if the current employee has a shift or any time-off booked already on 
                                * the current date of the schedule period and if does, then to skip this day. 
                                */
                                if(!(DAO.checkEmployeeShift(employee.getEmployeeID(), date.format(formatter))==true)){
                                                                         
                                     /*hard constraint - the following block checks if the employee has a shift booked the day before the current date as if does, will need to check the constraint 
                                     * for minimum hours between shifts has not been exceeded                        
                                     */
                                     
                                     //check if a shift exists the day before this day
                                     if(DAO.checkEmployeeShift(employee.getEmployeeID(), date.minusDays(1).format(formatter))==true){
                                         
                                        //if the above is true, then get the shift
                                        Shift shift2 = DAO.getEmployeeShift(employee.getEmployeeID(), date.minusDays(1).format(formatter));
                                       
                                        //now check if the shift is a working shift  
                                        if(shift2.getShiftType().equalsIgnoreCase("1")){
                                           
                                         //if working shift - get the duration between the end of this shift and the beginning of the proposed shift as none working shifts would have zero duration                                          
                                         LocalTime shiftEnd = LocalTime.parse(shift2.getShiftEnd());
                                         LocalTime shiftStart = startTime;
                                         int hours2 = Duration.ofHours(24).plus(Duration.between(shiftEnd, shiftStart)).toHoursPart();
                                         double minutes2 = Double.parseDouble(df.format((Duration.between(shiftEnd, shiftStart).toMinutesPart())*0.0166));
                                         double duration2 = hours2 + minutes2;
                                                                                  
                                                                     
                                            //hard constraint - now check that minimum hours between shifts as stated in the employee contract has not been exceeded
                                            if(duration2 >= Double.parseDouble(contract.getMinHoursBetweenShifts())){                                               

                                                //Now hard constraints checks finished consider any demands set by shift planner (staff required per day) and all soft constraints                                                                                               
                                                  
                                                //check that the number of currently assigned shifts have not exceeded the limit set under optional settings for the current day - if optinal settings are set
                                                if( ((date.getDayOfWeek().getValue()==1) && ((monTick.isSelected() && Integer.parseInt(mon.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) || 
                                                    ((date.getDayOfWeek().getValue()==2) && ((tueTick.isSelected() && Integer.parseInt(tue.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                    ((date.getDayOfWeek().getValue()==3) && ((wedTick.isSelected() && Integer.parseInt(wed.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                    ((date.getDayOfWeek().getValue()==4) && ((thuTick.isSelected() && Integer.parseInt(thu.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                    ((date.getDayOfWeek().getValue()==5) && ((friTick.isSelected() && Integer.parseInt(fri.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                    ((date.getDayOfWeek().getValue()==6) && ((satTick.isSelected() && Integer.parseInt(sat.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                    ((date.getDayOfWeek().getValue()==7) && ((sunTick.isSelected() && Integer.parseInt(sun.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ){
                                                           
                                                    
                                                    
                                                    
         //////////////////////                        //get consecutive days/shifts count for current employee                   
                                                       int consDays1 = Integer.parseInt(contract.getMaxConsWorkDays());
                                                       LocalDate startConsDays1 = date.minusDays(consDays1); 
                                                       int consShifts1 = 0;
                                                       
                                                       for (int b=0; b < consDays1; b++){
                                                        try{
                                                                Shift shift3 = DAO.getEmployeeShift(employee.getEmployeeID(), startConsDays1.format(formatter));
                                                                if (shift3.getShiftType().equalsIgnoreCase("1")){
                                                                    consShifts1 = consShifts1 + 1;
                                                                }                                                           
                                                            }
                                                        catch(NullPointerException s){
                                                                }
                                                        startConsDays1 = startConsDays1.plusDays(1);
                                                       }                                                                                                  
                                                    
                                                    /*if either of the current employee's preferred days off are on this weekday or consecutive days are reached 
                                                    * then look for another employee who may not prefer to be off on this day
                                                    */
                                                    if (Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                        Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                        consShifts1 >= Integer.parseInt(contract.getMaxConsWorkDays())){                                                                                                          
                                      
                                                        
                                                        Collections.shuffle(employeesSelected2);
                                                        //Now we will check if any other employees are available instead - will aim to find the next available only
                                                        for (Employee employee1 : employeesSelected2){
                                                            
                                                                //set assigned/allocated hours count to 0  
                                                                double assignedHours3=0;

                                                                //get and store employee contract (in this current loop) from database as we will need this for contract constraint checks
                                                                Contract contract1 = DAO.getContract(employee1.getEmployeeContract());

                                                                //store shift cost for the shift that will be created
                                                                double shiftCost1 = Double.parseDouble(df.format((DAO.getHourlyRate(employee1.getEmployeeID())) * totalDuration));                                   

                                                            //hard constraint - check that the current employee contract end date has not passed the current day in the schedule period                     
                                                            if(!(date.isAfter(LocalDate.parse(contract1.getContractEndDate())))){

                                                            //The following block of code then gets current number of working hours already assigned for the current employee
                                                            
                                                                //first set variables for finding the current whole week (mon-sun)in the chosen schedule period and setting the start and end dates for this week
                                                                LocalDate startOfWeek1 = date.with(DayOfWeek.MONDAY);
                                                                LocalDate endOfWeek1 = date.with(DayOfWeek.SUNDAY);
                                                                //sets period of days to iterate through to check for existing shifts
                                                                long weekPeriod1 = startOfWeek1.until(endOfWeek1, DAYS)+1;

                                                                LocalDate day1 = startOfWeek1;

                                                                    //for each day of the week in the projected schedule period
                                                                    for (int b=0; b < weekPeriod1; b++){                            

                                                                        //check if there are any existing shifts assigned
                                                                        if(DAO.checkEmployeeShift(employee1.getEmployeeID(), day1.format(formatter))==true){                                                                              

                                                                            //get the shift if it exists
                                                                            Shift shift1 = DAO.getEmployeeShift(employee1.getEmployeeID(), day1.format(formatter));

                                                                            //then check that this is a working shift using the shift type
                                                                            if(shift1.getShiftType().equalsIgnoreCase("1")){

                                                                                //if working shift then get the duration of hours and minutes for that shift    
                                                                                LocalTime shiftStart1 = LocalTime.parse(shift1.getShiftStart());
                                                                                LocalTime shiftEnd1 = LocalTime.parse(shift1.getShiftEnd());
                                                                                int hours3 = Duration.ofHours(24).plus(Duration.between(shiftStart1, shiftEnd1)).toHoursPart();
                                                                                double minutes3 = Double.parseDouble(df.format((Duration.between(shiftStart1, shiftEnd1).toMinutesPart())*0.0166)); 
                                                                                double duration3 = hours3 + minutes3;
                                                                                //set a variable for the day to 0 to store this duration
                                                                                double assignedHours4 = 0;

                                                                                //adds the duration to the day variable 
                                                                                assignedHours4 = Double.sum(assignedHours4, duration3);

                                                                                //passes the duration to a running total for the week
                                                                                assignedHours3 = Double.sum(assignedHours3, assignedHours4);  
                                                                            }
                                                                         }                                                                                                                                               
                                                                        //increment a day and continue the loop to get all assigned hours for that week 
                                                                        day1 = day1.plusDays(1);
                                                                    }//end of calculating working hours for the week                                      


                                                                    //hard constraint - now ensures the contracted weekly hours for the current employee will not been exceeded - if exceeded then will assign day off
                                                                    if (!(Double.sum(assignedHours3, totalDuration) > Double.parseDouble(contract1.getContractedHours()))){

                                                                        /*hard constraint (sick days, annual leave, etc) - check if the current employee has a shift or any time-off booked already on 
                                                                        * the current date of the schedule period and if does, then to skip this day. 
                                                                        */
                                                                        if(!(DAO.checkEmployeeShift(employee1.getEmployeeID(), date.format(formatter))==true)){

                                                                             /*hard constraint - the following block checks if the employee has a shift booked the day before the current date as if does, will need to check the constraint 
                                                                             * for minimum hours between shifts has not been exceeded                        
                                                                             */

                                                                         //check if a shift exists the day before this day
                                                                         if(DAO.checkEmployeeShift(employee1.getEmployeeID(), date.minusDays(1).format(formatter))==true){

                                                                             //if the above is true, then get the shift
                                                                             Shift shift3 = DAO.getEmployeeShift(employee1.getEmployeeID(), date.minusDays(1).format(formatter));

                                                                            //now check if the shift is a working shift  
                                                                            if(shift3.getShiftType().equalsIgnoreCase("1")){

                                                                             //if working shift - get the duration between the end of this shift and the beginning of the proposed shift                                          
                                                                             LocalTime shiftEnd1 = LocalTime.parse(shift3.getShiftEnd());
                                                                             LocalTime shiftStart1 = startTime;
                                                                             int hours3 = Duration.ofHours(24).plus(Duration.between(shiftEnd1, shiftStart1)).toHoursPart();
                                                                             double minutes3 = Double.parseDouble(df.format((Duration.between(shiftEnd1, shiftStart1).toMinutesPart())*0.0166));
                                                                             double duration3 = hours3 + minutes3;


                                                                                //hard constraint - now check that minimum hours between shifts as stated in the employee contract has not been exceeded
                                                                                if(duration3 >= Double.parseDouble(contract1.getMinHoursBetweenShifts())){
                                                                                    
                                                                                    //before assigning the shift check for consecutive working days (soft constraint) before this date                                                                  
                                                                                           int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                                           LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                                           int consShifts2 = 0;
                                                                                           for (int c=0; c < consDays2; c++){
                                                                                            try{
                                                                                                    Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                                    if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                                        consShifts2 = consShifts2 + 1;
                                                                                                    }                                                           
                                                                                                }
                                                                                            catch(NullPointerException s){
                                                                                                    }
                                                                                            startConsDays2 = startConsDays2.plusDays(1);
                                                                                           }
                                                                                    //System.out.println("employee1 at line: 1785 "+employee1.getEmployeeName());
                                                                                    if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                            Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                            consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){
                                                                                                                                                                                                                               
                                                                                                //assign the working shift
                                                                                                DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);
                                                                                                //System.out.println("Working shift assigned at line 1787 for "+employee1.getEmployeeName()+" "+date);
                                                                                                //if(!(employee1.getEmployeeID().equalsIgnoreCase(employee.getEmployeeID()))){                                                                                            
                                                                                                //assign day off
                                                                                                //DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                                                                //System.out.println("Day off assigned at line 1792 for "+employee.getEmployeeName()+" "+date);
                                                                                                //}
                                                                                                //break;   
                                                                                                
                                                                                                //get updated number of working shifts currently assigned on this day
                                                                                                numOfShiftsOnDay = DAO.getNumOfShiftsOnDay(date.format(formatter));

                                                                                                if(!(((date.getDayOfWeek().getValue()==1) && ((monTick.isSelected() && Integer.parseInt(mon.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) || 
                                                                                                   ((date.getDayOfWeek().getValue()==2) && ((tueTick.isSelected() && Integer.parseInt(tue.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                                   ((date.getDayOfWeek().getValue()==3) && ((wedTick.isSelected() && Integer.parseInt(wed.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                                   ((date.getDayOfWeek().getValue()==4) && ((thuTick.isSelected() && Integer.parseInt(thu.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                                   ((date.getDayOfWeek().getValue()==5) && ((friTick.isSelected() && Integer.parseInt(fri.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                                   ((date.getDayOfWeek().getValue()==6) && ((satTick.isSelected() && Integer.parseInt(sat.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                                   ((date.getDayOfWeek().getValue()==7) && ((sunTick.isSelected() && Integer.parseInt(sun.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))))){
                                                                                                    //System.out.println("day off created for "+employee.getEmployeeName()+" at line 1835");
                                                                                                    //assign day off to the original employee in the main loop
                                                                                                    DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);

                                                                                                    break;
                                                                                                }
                                                                                      }                                                                                    
                                                                                 }                                                        
                                                                              }
                                                                            else{
                                                                                //System.out.println("employee1 at line: 1803 "+employee1.getEmployeeName());
                                                                                //before assigning the shift check for consecutive working days (soft constraint) before this date                                                                  
                                                                               int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                               LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                               int consShifts2 = 0;
                                                                               for (int c=0; c < consDays2; c++){
                                                                                try{
                                                                                        Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                        if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                            consShifts2 = consShifts2 + 1;
                                                                                        }                                                           
                                                                                    }
                                                                                catch(NullPointerException s){
                                                                                        }
                                                                                startConsDays2 = startConsDays2.plusDays(1);
                                                                               }
                                                                               
                                                                               if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                    Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                    consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){
                                                                                                                                                                                                                               
                                                                                        //assign the working shift
                                                                                        DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);
                                                                                        //System.out.println("Working shift assigned at line 1821 for "+employee1.getEmployeeName()+" "+date);

                                                                                        //if(!(employee1.getEmployeeID().equalsIgnoreCase(employee.getEmployeeID()))){
                                                                                        //assign day off
                                                                                        //DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                                                        //System.out.println("Day off assigned at line 1827 for "+employee.getEmployeeName()+" "+date);
                                                                                        //}
                                                                                        //break;
                                                                                        
                                                                                        //get updated number of working shifts currently assigned on this day
                                                                                         numOfShiftsOnDay = DAO.getNumOfShiftsOnDay(date.format(formatter));
                                                                                         
                                                                                         if(!(((date.getDayOfWeek().getValue()==1) && ((monTick.isSelected() && Integer.parseInt(mon.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) || 
                                                                                            ((date.getDayOfWeek().getValue()==2) && ((tueTick.isSelected() && Integer.parseInt(tue.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                            ((date.getDayOfWeek().getValue()==3) && ((wedTick.isSelected() && Integer.parseInt(wed.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                            ((date.getDayOfWeek().getValue()==4) && ((thuTick.isSelected() && Integer.parseInt(thu.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                            ((date.getDayOfWeek().getValue()==5) && ((friTick.isSelected() && Integer.parseInt(fri.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                            ((date.getDayOfWeek().getValue()==6) && ((satTick.isSelected() && Integer.parseInt(sat.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                            ((date.getDayOfWeek().getValue()==7) && ((sunTick.isSelected() && Integer.parseInt(sun.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))))){
                                                                                             //System.out.println("day off created for "+employee.getEmployeeName()+" at line 1887");
                                                                                             //assign day off to the original employee in the main loop
                                                                                             DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                                                             
                                                                                             break;
                                                                                         }
                                                                                }
                                                                            }
                                                                         }
                                                                         else{
                                                                                //System.out.println("employee1 at line: 1838 "+employee1.getEmployeeName());
                                                                                //before assigning the shift check for consecutive working days (soft constraint) before this date                                                                  
                                                                               int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                               LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                               int consShifts2 = 0;
                                                                               for (int c=0; c < consDays2; c++){
                                                                                try{
                                                                                        Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                        if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                            consShifts2 = consShifts2 + 1;
                                                                                        }                                                           
                                                                                    }
                                                                                catch(NullPointerException s){
                                                                                        }
                                                                                startConsDays2 = startConsDays2.plusDays(1);
                                                                               }
                                                                               
                                                                               if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                    Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                    consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){
                                                                                                                                                                                                                               
                                                                                        //assign the working shift
                                                                                         DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);
                                                                                         //System.out.println("Working shift assigned at line 1856 for "+employee1.getEmployeeName()+" "+date);

                                                                                         
                                                                                         //if(!(employee1.getEmployeeID().equalsIgnoreCase(employee.getEmployeeID()))){
                                                                                         //assign day off
                                                                                         //DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                                                         //System.out.println("Day off assigned at line 1861 for "+employee.getEmployeeName()+" "+date);
                                                                                         //}                                                                                         
                                                                                         //break; 
                                                                                         
                                                                                         //get updated number of working shifts currently assigned on this day
                                                                                         numOfShiftsOnDay = DAO.getNumOfShiftsOnDay(date.format(formatter));
                                                                                         
                                                                                         if(!(((date.getDayOfWeek().getValue()==1) && ((monTick.isSelected() && Integer.parseInt(mon.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) || 
                                                                                            ((date.getDayOfWeek().getValue()==2) && ((tueTick.isSelected() && Integer.parseInt(tue.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                            ((date.getDayOfWeek().getValue()==3) && ((wedTick.isSelected() && Integer.parseInt(wed.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                            ((date.getDayOfWeek().getValue()==4) && ((thuTick.isSelected() && Integer.parseInt(thu.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                            ((date.getDayOfWeek().getValue()==5) && ((friTick.isSelected() && Integer.parseInt(fri.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                            ((date.getDayOfWeek().getValue()==6) && ((satTick.isSelected() && Integer.parseInt(sat.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                            ((date.getDayOfWeek().getValue()==7) && ((sunTick.isSelected() && Integer.parseInt(sun.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))))){
                                                                                             //System.out.println("day off created for "+employee.getEmployeeName()+" at line 1940");
                                                                                             //assign day off to the original employee in the main loop
                                                                                             DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                                                             
                                                                                             break;
                                                                                         }       
                                                                                }
                                                                            }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        if(!(DAO.checkEmployeeShift(employee.getEmployeeID(), date.format(formatter))==true)){
                                                            //assign the working shift
                                                            DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                                                            //System.out.println("Working shift assigned at line 1878 for "+employee.getEmployeeName()+" "+date);
                                                        }
                                                        
                                                    }
                                                    else{
                                                         //assign the working shift
                                                         DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                                                         //System.out.println("Working shift assigned at line 1885 for "+employee.getEmployeeName()+" "+date);
                                                    }                                                
                                                }                                                
                                                else if (((date.getDayOfWeek().getValue()==1) && ((monTick.isSelected() && Integer.parseInt(mon.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay))) || 
                                                        ((date.getDayOfWeek().getValue()==2) && ((tueTick.isSelected() && Integer.parseInt(tue.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay))) ||
                                                        ((date.getDayOfWeek().getValue()==3) && ((wedTick.isSelected() && Integer.parseInt(wed.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay))) ||
                                                        ((date.getDayOfWeek().getValue()==4) && ((thuTick.isSelected() && Integer.parseInt(thu.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay))) ||
                                                        ((date.getDayOfWeek().getValue()==5) && ((friTick.isSelected() && Integer.parseInt(fri.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay))) ||
                                                        ((date.getDayOfWeek().getValue()==6) && ((satTick.isSelected() && Integer.parseInt(sat.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay))) ||
                                                        ((date.getDayOfWeek().getValue()==7) && ((sunTick.isSelected() && Integer.parseInt(sun.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay))) ){
                                                        //System.out.println("day off created for "+employee.getEmployeeName()+" at line 1972");
                                                        //assign day off
                                                        DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                        //System.out.println("Day off assigned at line 1892 for "+employee.getEmployeeName()+" "+date);

                                                }
                                                //if there are no optional (settings) numbers of staff slected for each day
                                                //employee soft constraint preferences will prevail
                                                else{
                                                     
                                                     //check consecutive working days
                                                       int consDays1 = Integer.parseInt(contract.getMaxConsWorkDays());
                                                       LocalDate startConsDays1 = date.minusDays(consDays1); 
                                                       int consShifts1 = 0;
                                                       
                                                       for (int b=0; b < consDays1; b++){
                                                        try{
                                                                Shift shift3 = DAO.getEmployeeShift(employee.getEmployeeID(), startConsDays1.format(formatter));
                                                                if (shift3.getShiftType().equalsIgnoreCase("1")){
                                                                    consShifts1 = consShifts1 + 1;
                                                                }                                                           
                                                            }
                                                        catch(NullPointerException s){
                                                                }
                                                        startConsDays1 = startConsDays1.plusDays(1);
                                                       }
                                                    
                                                    if(Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                       Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                            consShifts1 >= Integer.parseInt(contract.getMaxConsWorkDays())){
                                                       //System.out.println("day off created for "+employee.getEmployeeName()+" at line 2002");
                                                        //assign day off
                                                        DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                        //System.out.println("Day off assigned at line 1917 for "+employee.getEmployeeName()+" "+date);
                                                    }                                                   
                                                    else{                                                            
                                                        //assign the working shift
                                                        DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                                                        //System.out.println("Working shift assigned at line 1924 for "+employee.getEmployeeName()+" "+date);
                                                    }                                                                                 
                                                }                                                                                                                                                   
                                            }
                                            else{//if duration of hours between last shift and new shift is under the minimum hours allowed between shifts as per contract
                                                //System.out.println("day off created for "+employee.getEmployeeName()+" at line 2015");
                                                //assign day off
                                                DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                //System.out.println("Day off assigned at line 1932 for "+employee.getEmployeeName()+" "+date);
                                            }
                                        }
                                        else{
                                                //check that the number of currently assigned shifts have not exceeded the limit set under optional settings for the current day
                                                if( ((date.getDayOfWeek().getValue()==1) && ((monTick.isSelected() && Integer.parseInt(mon.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) || 
                                                    ((date.getDayOfWeek().getValue()==2) && ((tueTick.isSelected() && Integer.parseInt(tue.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                    ((date.getDayOfWeek().getValue()==3) && ((wedTick.isSelected() && Integer.parseInt(wed.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                    ((date.getDayOfWeek().getValue()==4) && ((thuTick.isSelected() && Integer.parseInt(thu.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                    ((date.getDayOfWeek().getValue()==5) && ((friTick.isSelected() && Integer.parseInt(fri.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                    ((date.getDayOfWeek().getValue()==6) && ((satTick.isSelected() && Integer.parseInt(sat.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                    ((date.getDayOfWeek().getValue()==7) && ((sunTick.isSelected() && Integer.parseInt(sun.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay)))){
                                                                                                          
         //////////////////////                                           
                                                       int consDays1 = Integer.parseInt(contract.getMaxConsWorkDays());
                                                       LocalDate startConsDays1 = date.minusDays(consDays1); 
                                                       int consShifts1 = 0;
                                                       
                                                       for (int b=0; b < consDays1; b++){
                                                        try{
                                                                Shift shift3 = DAO.getEmployeeShift(employee.getEmployeeID(), startConsDays1.format(formatter));
                                                                if (shift3.getShiftType().equalsIgnoreCase("1")){
                                                                    consShifts1 = consShifts1 + 1;
                                                                }                                                           
                                                            }
                                                        catch(NullPointerException s){
                                                                }
                                                        startConsDays1 = startConsDays1.plusDays(1);
                                                       }                                                                                                  
                                                    
                                                    /*if either of the current employee's preferred days off are on this weekday or consecutive days are reached 
                                                    * then look for another employee who may not prefer to be off on this day
                                                    */
                                                    if (Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                            Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                            consShifts1 >= Integer.parseInt(contract.getMaxConsWorkDays())){                                                                                                          
                                                        
                                                        Collections.shuffle(employeesSelected2);
                                                        //Now we will check if any other employees are available instead - will find the next available only
                                                        for (Employee employee1 : employeesSelected2){
                                                            
                                                            //set assigned/allocated hours count to 0  
                                                            double assignedHours3=0;

                                                            //get and store employee contract (in this current loop) from database as we will need this for contract constraint checks
                                                            Contract contract1 = DAO.getContract(employee1.getEmployeeContract());

                                                            //store shift cost for the shift that will be created
                                                            double shiftCost1 = Double.parseDouble(df.format((DAO.getHourlyRate(employee1.getEmployeeID())) * totalDuration));                                   

                                                            //hard constraint - check that the current employee contract end date has not passed the current day in the schedule period                     
                                                            if(!(date.isAfter(LocalDate.parse(contract1.getContractEndDate())))){

                                                            //The following block of code then gets current number of working hours already assigned for the current employee
                                                            
                                                                //first set variables for finding the current whole week (mon-sun)in the chosen schedule period and setting the start and end dates for this week
                                                                LocalDate startOfWeek1 = date.with(DayOfWeek.MONDAY);
                                                                LocalDate endOfWeek1 = date.with(DayOfWeek.SUNDAY);
                                                                //sets period of days to iterate through to check for existing shifts
                                                                long weekPeriod1 = startOfWeek1.until(endOfWeek1, DAYS)+1;

                                                                LocalDate day1 = startOfWeek1;

                                                                    //for each day of the first week in the projected schedule period
                                                                    for (int b=0; b < weekPeriod1; b++){                            

                                                                        //check if there are any existing shifts assigned
                                                                        if(DAO.checkEmployeeShift(employee1.getEmployeeID(), day1.format(formatter))==true){                                                                              

                                                                            //get the shift if it exists
                                                                            Shift shift1 = DAO.getEmployeeShift(employee1.getEmployeeID(), day1.format(formatter));

                                                                            //then check that this is a working shift using the shift type
                                                                            if(shift1.getShiftType().equalsIgnoreCase("1")){

                                                                                //if working shift then get the duration of hours and minutes for that shift    
                                                                                LocalTime shiftStart1 = LocalTime.parse(shift1.getShiftStart());
                                                                                LocalTime shiftEnd1 = LocalTime.parse(shift1.getShiftEnd());
                                                                                int hours3 = Duration.ofHours(24).plus(Duration.between(shiftStart1, shiftEnd1)).toHoursPart();
                                                                                double minutes3 = Double.parseDouble(df.format((Duration.between(shiftStart1, shiftEnd1).toMinutesPart())*0.0166)); 
                                                                                double duration3 = hours3 + minutes3;
                                                                                //set a variable for the day to 0 to store this duration
                                                                                double assignedHours4 = 0;

                                                                                //adds the duration to the day variable 
                                                                                assignedHours4 = Double.sum(assignedHours4, duration3);

                                                                                //passes the duration to a running total for the week
                                                                                assignedHours3 = Double.sum(assignedHours3, assignedHours4);  
                                                                            }
                                                                         }                                                                                                                                               
                                                                        //increment a day and continue the loop to get all assigned hours for that week 
                                                                        day1 = day1.plusDays(1);
                                                                    }//end of calculating working hours for the week                                      


                                                                    //hard constraint - now ensures the contracted weekly hours for the current employee will not been exceeded - if exceeded then will assign day off
                                                                    if (!(Double.sum(assignedHours3, totalDuration) > Double.parseDouble(contract1.getContractedHours()))){

                                                                        /*hard constraint (sick days, annual leave, etc) - check if the current employee has a shift or any time-off booked already on 
                                                                        * the current date of the schedule period and if does, then to skip this day. 
                                                                        */
                                                                        if(!(DAO.checkEmployeeShift(employee1.getEmployeeID(), date.format(formatter))==true)){

                                                                             /*hard constraint - the following block checks if the employee has a shift booked the day before the current date as if does, will need to check the constraint 
                                                                             * for minimum hours between shifts has not been exceeded                        
                                                                             */

                                                                         //check if a shift exists the day before this day
                                                                         if(DAO.checkEmployeeShift(employee1.getEmployeeID(), date.minusDays(1).format(formatter))==true){

                                                                             //if the above is true, then get the shift
                                                                             Shift shift3 = DAO.getEmployeeShift(employee1.getEmployeeID(), date.minusDays(1).format(formatter));

                                                                            //now check if the shift is a working shift  
                                                                            if(shift3.getShiftType().equalsIgnoreCase("1")){

                                                                             //if working shift - get the duration between the end of this shift and the beginning of the proposed shift                                          
                                                                             LocalTime shiftEnd1 = LocalTime.parse(shift3.getShiftEnd());
                                                                             LocalTime shiftStart1 = startTime;
                                                                             int hours3 = Duration.ofHours(24).plus(Duration.between(shiftEnd1, shiftStart1)).toHoursPart();
                                                                             double minutes3 = Double.parseDouble(df.format((Duration.between(shiftEnd1, shiftStart1).toMinutesPart())*0.0166));
                                                                             double duration3 = hours3 + minutes3;


                                                                                //hard constraint - now check that minimum hours between shifts as stated in the employee contract has not been exceeded
                                                                                if(duration3 >= Double.parseDouble(contract1.getMinHoursBetweenShifts())){
                                                                                    
                                                                                    //before assigning the shift check for consecutive working days (soft constraint) before this date   
                                                                               
                                                                                           int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                                           LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                                           int consShifts2 = 0;
                                                                                           for (int c=0; c < consDays2; c++){
                                                                                            try{
                                                                                                    Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                                    if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                                        consShifts2 = consShifts2 + 1;
                                                                                                    }                                                           
                                                                                                }
                                                                                            catch(NullPointerException s){
                                                                                                    }
                                                                                            startConsDays2 = startConsDays2.plusDays(1);
                                                                                           }
                                                                                    
                                                                                            if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                                Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                                consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){
                                                                                                                                                                                                                               
                                                                                                //assign the working shift
                                                                                                DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);
                                                                                                //System.out.println("Working shift assigned at line 2081 for "+employee1.getEmployeeName()+" "+date);

                                                                                                //if(!(employee1.getEmployeeID().equalsIgnoreCase(employee.getEmployeeID()))){
                                                                                                //assign day off
                                                                                                //DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                                                                //System.out.println("Day off assigned at line 2086 for "+employee.getEmployeeName()+" "+date);

                                                                                                //}
                                                                                                //break; 
                                                                                                
                                                                                                //update number of working shifts currently assigned on this day
                                                                                                numOfShiftsOnDay = DAO.getNumOfShiftsOnDay(date.format(formatter));

                                                                                                if(!(((date.getDayOfWeek().getValue()==1) && ((monTick.isSelected() && Integer.parseInt(mon.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) || 
                                                                                                   ((date.getDayOfWeek().getValue()==2) && ((tueTick.isSelected() && Integer.parseInt(tue.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                                   ((date.getDayOfWeek().getValue()==3) && ((wedTick.isSelected() && Integer.parseInt(wed.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                                   ((date.getDayOfWeek().getValue()==4) && ((thuTick.isSelected() && Integer.parseInt(thu.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                                   ((date.getDayOfWeek().getValue()==5) && ((friTick.isSelected() && Integer.parseInt(fri.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                                   ((date.getDayOfWeek().getValue()==6) && ((satTick.isSelected() && Integer.parseInt(sat.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                                   ((date.getDayOfWeek().getValue()==7) && ((sunTick.isSelected() && Integer.parseInt(sun.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))))){
                                                                                                    //System.out.println("day off created for "+employee.getEmployeeName()+" at line 2189");
                                                                                                    //assign day off to the original employee in the main loop
                                                                                                    DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);

                                                                                                    break;
                                                                                                }
                                                                                    }                                                                                    
                                                                                 }                                                                               
                                                                              }
                                                                            else{
                                                                                 //before assigning the shift check for consecutive working days (soft constraint) before this date   
                                                                               
                                                                                           int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                                           LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                                           int consShifts2 = 0;
                                                                                           for (int c=0; c < consDays2; c++){
                                                                                            try{
                                                                                                    Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                                    if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                                        consShifts2 = consShifts2 + 1;
                                                                                                    }                                                           
                                                                                                }
                                                                                            catch(NullPointerException s){
                                                                                                    }
                                                                                            startConsDays2 = startConsDays2.plusDays(1);
                                                                                           }
                                                                                    
                                                                                            if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                                Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                                consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){
                                                                                                                                                                                                                               
                                                                                                //assign the working shift
                                                                                                DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);
                                                                                                //System.out.println("Working shift assigned at line 2117 for "+employee1.getEmployeeName()+" "+date);

                                                                                                //if(!(employee1.getEmployeeID().equalsIgnoreCase(employee.getEmployeeID()))){
                                                                                                //assign day off
                                                                                                //DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                                                                //System.out.println("Day off assigned at line 2122 for "+employee.getEmployeeName()+" "+date);

                                                                                                //}
                                                                                                //break; 
                                                                                                //get updated number of working shifts currently assigned on this day
                                                                                                numOfShiftsOnDay = DAO.getNumOfShiftsOnDay(date.format(formatter));

                                                                                                if(!(((date.getDayOfWeek().getValue()==1) && ((monTick.isSelected() && Integer.parseInt(mon.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) || 
                                                                                                   ((date.getDayOfWeek().getValue()==2) && ((tueTick.isSelected() && Integer.parseInt(tue.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                                   ((date.getDayOfWeek().getValue()==3) && ((wedTick.isSelected() && Integer.parseInt(wed.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                                   ((date.getDayOfWeek().getValue()==4) && ((thuTick.isSelected() && Integer.parseInt(thu.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                                   ((date.getDayOfWeek().getValue()==5) && ((friTick.isSelected() && Integer.parseInt(fri.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                                   ((date.getDayOfWeek().getValue()==6) && ((satTick.isSelected() && Integer.parseInt(sat.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                                   ((date.getDayOfWeek().getValue()==7) && ((sunTick.isSelected() && Integer.parseInt(sun.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))))){
                                                                                                    //System.out.println("day off created for "+employee.getEmployeeName()+" at line 2241");
                                                                                                    //assign day off to the original employee in the main loop
                                                                                                    DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);

                                                                                                    break;
                                                                                                }
                                                                                            }
                                                                            }
                                                                         }
                                                                         else{
                                                                              //before assigning the shift check for consecutive working days (soft constraint) before this date   

                                                                            int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                            LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                            int consShifts2 = 0;
                                                                            for (int c=0; c < consDays2; c++){
                                                                             try{
                                                                                     Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                     if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                         consShifts2 = consShifts2 + 1;
                                                                                     }                                                           
                                                                                 }
                                                                             catch(NullPointerException s){
                                                                                     }
                                                                             startConsDays2 = startConsDays2.plusDays(1);
                                                                            }

                                                                             if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                 Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                 consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){

                                                                                 //assign the working shift
                                                                                DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);
                                                                                //System.out.println("Working shift assigned at line 2153 for "+employee1.getEmployeeName()+" "+date);

                                                                                //if(!(employee1.getEmployeeID().equalsIgnoreCase(employee.getEmployeeID()))){
                                                                                //assign day off
                                                                                //DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                                                //System.out.println("Day off assigned at line 2158 for "+employee.getEmployeeName()+" "+date);

                                                                                //}
                                                                                //break;
                                                                                //get updated number of working shifts currently assigned on this day
                                                                                numOfShiftsOnDay = DAO.getNumOfShiftsOnDay(date.format(formatter));

                                                                                if(!(((date.getDayOfWeek().getValue()==1) && ((monTick.isSelected() && Integer.parseInt(mon.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) || 
                                                                                   ((date.getDayOfWeek().getValue()==2) && ((tueTick.isSelected() && Integer.parseInt(tue.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                   ((date.getDayOfWeek().getValue()==3) && ((wedTick.isSelected() && Integer.parseInt(wed.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                   ((date.getDayOfWeek().getValue()==4) && ((thuTick.isSelected() && Integer.parseInt(thu.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                   ((date.getDayOfWeek().getValue()==5) && ((friTick.isSelected() && Integer.parseInt(fri.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                   ((date.getDayOfWeek().getValue()==6) && ((satTick.isSelected() && Integer.parseInt(sat.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                   ((date.getDayOfWeek().getValue()==7) && ((sunTick.isSelected() && Integer.parseInt(sun.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))))){
                                                                                    //System.out.println("day off created for "+employee.getEmployeeName()+" at line 2293");
                                                                                    //assign day off to the original employee in the main loop
                                                                                    DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);

                                                                                    break;
                                                                                }

                                                                            }
                                                                         }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        if(!(DAO.checkEmployeeShift(employee.getEmployeeID(), date.format(formatter))==true)){
                                                            //assign the working shift
                                                            DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                                                            //System.out.println("Working shift assigned at line 1878 for "+employee.getEmployeeName()+" "+date);
                                                        }
                                                    }
                                                    else{
                                                         //assign the working shift
                                                         DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                                                         //System.out.println("Working shift assigned at line 2173 for "+employee.getEmployeeName()+" "+date);
                                                    }
                                                }                                                
                                                else if (((date.getDayOfWeek().getValue()==1) && ((monTick.isSelected() && Integer.parseInt(mon.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay))) || 
                                                        ((date.getDayOfWeek().getValue()==2) && ((tueTick.isSelected() && Integer.parseInt(tue.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay))) ||
                                                        ((date.getDayOfWeek().getValue()==3) && ((wedTick.isSelected() && Integer.parseInt(wed.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay))) ||
                                                        ((date.getDayOfWeek().getValue()==4) && ((thuTick.isSelected() && Integer.parseInt(thu.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay))) ||
                                                        ((date.getDayOfWeek().getValue()==5) && ((friTick.isSelected() && Integer.parseInt(fri.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay))) ||
                                                        ((date.getDayOfWeek().getValue()==6) && ((satTick.isSelected() && Integer.parseInt(sat.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay))) ||
                                                        ((date.getDayOfWeek().getValue()==7) && ((sunTick.isSelected() && Integer.parseInt(sun.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay))) ){
                                                        //System.out.println("day off created for "+employee.getEmployeeName()+" at line 2325");
                                                        //assign day off
                                                        DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0); 
                                                        //System.out.println("Day off assigned at line 2187 for "+employee.getEmployeeName()+" "+date);
                                                }
                                                else{   
                                                    //check consecutive working days
                                                       int consDays1 = Integer.parseInt(contract.getMaxConsWorkDays());
                                                       LocalDate startConsDays1 = date.minusDays(consDays1); 
                                                       int consShifts1 = 0;
                                                       
                                                       for (int b=0; b < consDays1; b++){
                                                        try{
                                                                Shift shift3 = DAO.getEmployeeShift(employee.getEmployeeID(), startConsDays1.format(formatter));
                                                                if (shift3.getShiftType().equalsIgnoreCase("1")){
                                                                    consShifts1 = consShifts1 + 1;
                                                                }                                                           
                                                            }
                                                        catch(NullPointerException s){
                                                                }
                                                        startConsDays1 = startConsDays1.plusDays(1);
                                                       }
                                                    
                                                    if(Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                       Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                            consShifts1 >= Integer.parseInt(contract.getMaxConsWorkDays())){
                                                        //System.out.println("day off created for "+employee.getEmployeeName()+" at line 2351");
                                                        //assign day off
                                                        DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                        //System.out.println("Day off assigned at line 2214 for "+employee.getEmployeeName()+" "+date);

                                                    }
                                                    else{                                                                                                                                                                                                                                  
                                                        //assign the working shift
                                                        DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);                                                                                                                                         
                                                        //System.out.println("Working shift assigned at line 2220 for "+employee.getEmployeeName()+" "+date);

                                                    }                                                       
                                                }
                                        }
                                     }
                                     else{
                                         //check that the number of currently assigned shifts have not exceeded the limit set under optional settings for the current day
                                        if( ((date.getDayOfWeek().getValue()==1) && ((monTick.isSelected() && Integer.parseInt(mon.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) || 
                                            ((date.getDayOfWeek().getValue()==2) && ((tueTick.isSelected() && Integer.parseInt(tue.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                            ((date.getDayOfWeek().getValue()==3) && ((wedTick.isSelected() && Integer.parseInt(wed.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                            ((date.getDayOfWeek().getValue()==4) && ((thuTick.isSelected() && Integer.parseInt(thu.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                            ((date.getDayOfWeek().getValue()==5) && ((friTick.isSelected() && Integer.parseInt(fri.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                            ((date.getDayOfWeek().getValue()==6) && ((satTick.isSelected() && Integer.parseInt(sat.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                            ((date.getDayOfWeek().getValue()==7) && ((sunTick.isSelected() && Integer.parseInt(sun.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ){
                                                                                                          
        /////////////////                        //calculate consecutive days                   
                                                  int consDays1 = Integer.parseInt(contract.getMaxConsWorkDays());
                                                  LocalDate startConsDays1 = date.minusDays(consDays1); 
                                                  int consShifts1 = 0;

                                                  for (int b=0; b < consDays1; b++){
                                                   try{
                                                           Shift shift3 = DAO.getEmployeeShift(employee.getEmployeeID(), startConsDays1.format(formatter));
                                                           if (shift3.getShiftType().equalsIgnoreCase("1")){
                                                               consShifts1 = consShifts1 + 1;
                                                           }                                                           
                                                       }
                                                   catch(NullPointerException s){
                                                           }
                                                   startConsDays1 = startConsDays1.plusDays(1);
                                                  }                                                                                                  
                                                    
                                                    /*if either of the current employee's preferred days off are on this weekday or consecutive days are reached 
                                                    * then look for another employee who may not prefer to be off on this day
                                                    */
                                                    if (Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                        Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                        consShifts1 >= Integer.parseInt(contract.getMaxConsWorkDays())){                                                                                                          
                                      
                                                        Collections.shuffle(employeesSelected2);
                                                        //Now we will check if any other employees are available instead - will find the next available only
                                                        for (Employee employee1 : employeesSelected2){
                                                            
                                                            //set assigned/allocated hours count to 0  
                                                            double assignedHours3=0;

                                                            //get and store employee contract (in this current loop) from database as we will need this for contract constraint checks
                                                            Contract contract1 = DAO.getContract(employee1.getEmployeeContract());

                                                            //store shift cost for the shift that will be created
                                                            double shiftCost1 = Double.parseDouble(df.format((DAO.getHourlyRate(employee1.getEmployeeID())) * totalDuration));                                   

                                                            //hard constraint - check that the current employee contract end date has not passed the current day in the schedule period                     
                                                            if(!(date.isAfter(LocalDate.parse(contract1.getContractEndDate())))){

                                                            //The following block of code then gets current number of working hours already assigned for the current employee

                                                            //first set variables for finding the current whole week (mon-sun)in the chosen schedule period and setting the start and end dates for this week
                                                            LocalDate startOfWeek1 = date.with(DayOfWeek.MONDAY);
                                                            LocalDate endOfWeek1 = date.with(DayOfWeek.SUNDAY);
                                                            //sets period of days to iterate through to check for existing shifts
                                                            long weekPeriod1 = startOfWeek1.until(endOfWeek1, DAYS)+1;

                                                            LocalDate day1 = startOfWeek1;

                                                                //for each day of the first week in the projected schedule period
                                                                for (int b=0; b < weekPeriod1; b++){                            

                                                                    //check if there are any existing shifts assigned
                                                                    if(DAO.checkEmployeeShift(employee1.getEmployeeID(), day1.format(formatter))==true){                                                                              

                                                                        //get the shift if it exists
                                                                        Shift shift1 = DAO.getEmployeeShift(employee1.getEmployeeID(), day1.format(formatter));

                                                                        //then check that this is a working shift using the shift type
                                                                        if(shift1.getShiftType().equalsIgnoreCase("1")){

                                                                            //if working shift then get the duration of hours and minutes for that shift    
                                                                            LocalTime shiftStart1 = LocalTime.parse(shift1.getShiftStart());
                                                                            LocalTime shiftEnd1 = LocalTime.parse(shift1.getShiftEnd());
                                                                            int hours3 = Duration.ofHours(24).plus(Duration.between(shiftStart1, shiftEnd1)).toHoursPart();
                                                                            double minutes3 = Double.parseDouble(df.format((Duration.between(shiftStart1, shiftEnd1).toMinutesPart())*0.0166)); 
                                                                            double duration3 = hours3 + minutes3;
                                                                            //set a variable for the day to 0 to store this duration
                                                                            double assignedHours4 = 0;

                                                                            //adds the duration to the day variable 
                                                                            assignedHours4 = Double.sum(assignedHours4, duration3);

                                                                            //passes the duration to a running total for the week
                                                                            assignedHours3 = Double.sum(assignedHours3, assignedHours4);  
                                                                            }
                                                                         }                                                                                                                                               
                                                                    //increment a day and continue the loop to get all assigned hours for that week 
                                                                    day1 = day1.plusDays(1);
                                                                }//end of calculating working hours for the week                                      


                                                                //hard constraint - now ensures the contracted weekly hours for the current employee will not been exceeded - if exceeded then will assign day off
                                                                if (!(Double.sum(assignedHours3, totalDuration) > Double.parseDouble(contract1.getContractedHours()))){

                                                                    /*hard constraint (sick days, annual leave, etc) - check if the current employee has a shift or any time-off booked already on 
                                                                    * the current date of the schedule period and if does, then to skip this day. 
                                                                    */
                                                                    if(!(DAO.checkEmployeeShift(employee1.getEmployeeID(), date.format(formatter))==true)){

                                                                    /*hard constraint - the following block checks if the employee has a shift booked the day before the current date as if does, will need to check the constraint 
                                                                    * for minimum hours between shifts has not been exceeded                        
                                                                    */

                                                                        //check if a shift exists the day before this day
                                                                        if(DAO.checkEmployeeShift(employee1.getEmployeeID(), date.minusDays(1).format(formatter))==true){

                                                                        //if the above is true, then get the shift
                                                                        Shift shift3 = DAO.getEmployeeShift(employee1.getEmployeeID(), date.minusDays(1).format(formatter));

                                                                            //now check if the shift is a working shift  
                                                                            if(shift3.getShiftType().equalsIgnoreCase("1")){

                                                                            //if working shift - get the duration between the end of this shift and the beginning of the proposed shift                                          
                                                                            LocalTime shiftEnd1 = LocalTime.parse(shift3.getShiftEnd());
                                                                            LocalTime shiftStart1 = startTime;
                                                                            int hours3 = Duration.ofHours(24).plus(Duration.between(shiftEnd1, shiftStart1)).toHoursPart();
                                                                            double minutes3 = Double.parseDouble(df.format((Duration.between(shiftEnd1, shiftStart1).toMinutesPart())*0.0166));
                                                                            double duration3 = hours3 + minutes3;

                                                                                //hard constraint - now check that minimum hours between shifts as stated in the employee contract has not been exceeded
                                                                                if(duration3 >= Double.parseDouble(contract1.getMinHoursBetweenShifts())){
                                                                                    
                                                                                    //before assigning the shift check for consecutive working days (soft constraint) before this date   
        
                                                                                    int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                                    LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                                    int consShifts2 = 0;
                                                                                    for (int c=0; c < consDays2; c++){
                                                                                     try{
                                                                                             Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                             if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                                 consShifts2 = consShifts2 + 1;
                                                                                             }                                                           
                                                                                         }
                                                                                     catch(NullPointerException s){
                                                                                             }
                                                                                     startConsDays2 = startConsDays2.plusDays(1);
                                                                                    }
                                                                                    
                                                                                    if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                        Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                        consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){
                                                                                                                                                                                                                               
                                                                                        //assign the working shift
                                                                                        DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);
                                                                                        //System.out.println("Working shift assigned at line 2372 for "+employee1.getEmployeeName()+" "+date);

                                                                                        //if(!(employee1.getEmployeeID().equalsIgnoreCase(employee.getEmployeeID()))){
                                                                                        //assign day off
                                                                                        //DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                                                        //System.out.println("Day off assigned at line 2377 for "+employee.getEmployeeName()+" "+date);

                                                                                        //}
                                                                                        //break;
                                                                                        //get updated number of working shifts currently assigned on this day
                                                                                         numOfShiftsOnDay = DAO.getNumOfShiftsOnDay(date.format(formatter));
                                                                                         
                                                                                         if(!(((date.getDayOfWeek().getValue()==1) && ((monTick.isSelected() && Integer.parseInt(mon.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) || 
                                                                                            ((date.getDayOfWeek().getValue()==2) && ((tueTick.isSelected() && Integer.parseInt(tue.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                            ((date.getDayOfWeek().getValue()==3) && ((wedTick.isSelected() && Integer.parseInt(wed.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                            ((date.getDayOfWeek().getValue()==4) && ((thuTick.isSelected() && Integer.parseInt(thu.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                            ((date.getDayOfWeek().getValue()==5) && ((friTick.isSelected() && Integer.parseInt(fri.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                            ((date.getDayOfWeek().getValue()==6) && ((satTick.isSelected() && Integer.parseInt(sat.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                            ((date.getDayOfWeek().getValue()==7) && ((sunTick.isSelected() && Integer.parseInt(sun.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))))){
                                                                                             //System.out.println("day off created for "+employee.getEmployeeName()+" at line 2532");
                                                                                             //assign day off to the original employee in the main loop
                                                                                             DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                                                             
                                                                                             break;
                                                                                         }
                                                                                    
                                                                                    }
                                                                                    
                                                                                 }                                                        
                                                                              }
                                                                            else{
                                                                                int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                                LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                                int consShifts2 = 0;
                                                                                for (int c=0; c < consDays2; c++){
                                                                                 try{
                                                                                         Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                         if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                             consShifts2 = consShifts2 + 1;
                                                                                         }                                                           
                                                                                     }
                                                                                 catch(NullPointerException s){
                                                                                         }
                                                                                 startConsDays2 = startConsDays2.plusDays(1);
                                                                                }

                                                                                if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                        Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                        consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){

                                                                                        //assign the working shift
                                                                                        DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);
                                                                                        //System.out.println("Working shift assigned at line 2408 for "+employee1.getEmployeeName()+" "+date);

                                                                                        //if(!(employee1.getEmployeeID().equalsIgnoreCase(employee.getEmployeeID()))){
                                                                                        //assign day off
                                                                                        //DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                                                        //System.out.println("Day off assigned at line 2413 for "+employee.getEmployeeName()+" "+date);

                                                                                        //}
                                                                                        //break;
                                                                                        //get updated number of working shifts currently assigned on this day
                                                                                         numOfShiftsOnDay = DAO.getNumOfShiftsOnDay(date.format(formatter));
                                                                                         
                                                                                         if(!(((date.getDayOfWeek().getValue()==1) && ((monTick.isSelected() && Integer.parseInt(mon.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) || 
                                                                                            ((date.getDayOfWeek().getValue()==2) && ((tueTick.isSelected() && Integer.parseInt(tue.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                            ((date.getDayOfWeek().getValue()==3) && ((wedTick.isSelected() && Integer.parseInt(wed.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                            ((date.getDayOfWeek().getValue()==4) && ((thuTick.isSelected() && Integer.parseInt(thu.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                            ((date.getDayOfWeek().getValue()==5) && ((friTick.isSelected() && Integer.parseInt(fri.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                            ((date.getDayOfWeek().getValue()==6) && ((satTick.isSelected() && Integer.parseInt(sat.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                            ((date.getDayOfWeek().getValue()==7) && ((sunTick.isSelected() && Integer.parseInt(sun.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))))){
                                                                                             //System.out.println("day off created for "+employee.getEmployeeName()+" at line 2584");
                                                                                             //assign day off to the original employee in the main loop
                                                                                             DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                                                             
                                                                                             break;
                                                                                         }
                                                                                }
                                                                            }
                                                                         }
                                                                        else{
                                                                            int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                            LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                            int consShifts2 = 0;
                                                                            for (int c=0; c < consDays2; c++){
                                                                             try{
                                                                                     Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                     if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                         consShifts2 = consShifts2 + 1;
                                                                                     }                                                           
                                                                                 }
                                                                             catch(NullPointerException s){
                                                                                     }
                                                                             startConsDays2 = startConsDays2.plusDays(1);
                                                                            }

                                                                            if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                    Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                    consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){

                                                                                    //assign the working shift
                                                                                    DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);
                                                                                    //System.out.println("Working shift assigned at line 2442 for "+employee1.getEmployeeName()+" "+date);

                                                                                    //if(!(employee1.getEmployeeID().equalsIgnoreCase(employee.getEmployeeID()))){
                                                                                    //assign day off
                                                                                    //DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                                                    //System.out.println("Day off assigned at line 2447 for "+employee.getEmployeeName()+" "+date);

                                                                                    //}
                                                                                    //break;
                                                                                    //get updated number of working shifts currently assigned on this day
                                                                                    numOfShiftsOnDay = DAO.getNumOfShiftsOnDay(date.format(formatter));

                                                                                    if(!(((date.getDayOfWeek().getValue()==1) && ((monTick.isSelected() && Integer.parseInt(mon.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) || 
                                                                                       ((date.getDayOfWeek().getValue()==2) && ((tueTick.isSelected() && Integer.parseInt(tue.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                       ((date.getDayOfWeek().getValue()==3) && ((wedTick.isSelected() && Integer.parseInt(wed.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                       ((date.getDayOfWeek().getValue()==4) && ((thuTick.isSelected() && Integer.parseInt(thu.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                       ((date.getDayOfWeek().getValue()==5) && ((friTick.isSelected() && Integer.parseInt(fri.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                       ((date.getDayOfWeek().getValue()==6) && ((satTick.isSelected() && Integer.parseInt(sat.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))) ||
                                                                                       ((date.getDayOfWeek().getValue()==7) && ((sunTick.isSelected() && Integer.parseInt(sun.getText())>numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>numOfShiftsOnDay))))){
                                                                                        //System.out.println("day off created for "+employee.getEmployeeName()+" at line 2634");
                                                                                        //assign day off to the original employee in the main loop
                                                                                        DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);

                                                                                        break;
                                                                                    }

                                                                            }
                                                                        }
                                                                    }                                                                                                                                  
                                                                }
                                                            }
                                                        }
                                                        if(!(DAO.checkEmployeeShift(employee.getEmployeeID(), date.format(formatter))==true)){
                                                            //assign the working shift
                                                            DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                                                            //System.out.println("Working shift assigned at line 2481 for "+employee.getEmployeeName()+" "+date);
                                                        }
                                                    }
                                                    else{
                                                         //assign the working shift
                                                         DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                                                         //System.out.println("Working shift assigned at line 2496 for "+employee.getEmployeeName()+" "+date);

                                                    }
                                                }                                                
                                                else if (((date.getDayOfWeek().getValue()==1) && ((monTick.isSelected() && Integer.parseInt(mon.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay))) || 
                                                        ((date.getDayOfWeek().getValue()==2) && ((tueTick.isSelected() && Integer.parseInt(tue.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay))) ||
                                                        ((date.getDayOfWeek().getValue()==3) && ((wedTick.isSelected() && Integer.parseInt(wed.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay))) ||
                                                        ((date.getDayOfWeek().getValue()==4) && ((thuTick.isSelected() && Integer.parseInt(thu.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay))) ||
                                                        ((date.getDayOfWeek().getValue()==5) && ((friTick.isSelected() && Integer.parseInt(fri.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay))) ||
                                                        ((date.getDayOfWeek().getValue()==6) && ((satTick.isSelected() && Integer.parseInt(sat.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay))) ||
                                                        ((date.getDayOfWeek().getValue()==7) && ((sunTick.isSelected() && Integer.parseInt(sun.getText())<=numOfShiftsOnDay) || (allDaysTick.isSelected() && Integer.parseInt(allDays.getText())<=numOfShiftsOnDay)))){
                                                        //System.out.println("day off created for "+employee.getEmployeeName()+" at line 2667");
                                                        //assign day off
                                                        DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                        //System.out.println("Day off assigned at line 2510 for "+employee.getEmployeeName()+" "+date);
    
                                                }
                                                else{                                                       
                                                    //check consecutive working days
                                                    int consDays1 = Integer.parseInt(contract.getMaxConsWorkDays());
                                                    LocalDate startConsDays1 = date.minusDays(consDays1); 
                                                    int consShifts1 = 0;

                                                    for (int b=0; b < consDays1; b++){
                                                     try{
                                                             Shift shift3 = DAO.getEmployeeShift(employee.getEmployeeID(), startConsDays1.format(formatter));
                                                             if (shift3.getShiftType().equalsIgnoreCase("1")){
                                                                 consShifts1 = consShifts1 + 1;
                                                             }                                                           
                                                         }
                                                     catch(NullPointerException s){
                                                             }
                                                     startConsDays1 = startConsDays1.plusDays(1);
                                                    }
                                                    
                                                    if(Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                        Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                        consShifts1 >= Integer.parseInt(contract.getMaxConsWorkDays())){
                                                        //System.out.println("day off created for "+employee.getEmployeeName()+" at line 2694");
                                                        //assign day off
                                                        DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                                        //System.out.println("Day off assigned at line 2537 for "+employee.getEmployeeName()+" "+date);

                                                    }
                                                    else{                              
                                                        //assign the working shift
                                                        DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost); 
                                                        //System.out.println("Working shift assigned at line 2543 for "+employee.getEmployeeName()+" "+date);

                                                    }                                                       
                                                }                                     
                                            }
                                     }  
                            }
                            else{
                                //check if any shifts have been assigned in previous loops for this day
                                if(!(DAO.checkEmployeeShift(employee.getEmployeeID(), date.format(formatter))==true)){
                                //System.out.println("day off created for "+employee.getEmployeeName()+" at line 2711");
                                //assign day off
                                DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);
                                //System.out.println("Day off assigned at line 2556 for "+employee.getEmployeeName()+" "+date);
                                }
                            }
                        } 
                        
                      
                     }
           
                } //complete the full loop for the remaining days of the schedule period
                  //System.out.println("Finished loop");
                  Stage autoShedule = (Stage) this.autoShiftCancelButton.getScene().getWindow();
                  autoShedule.close();
                  
                  refreshCalendar();//update the calendar                 
            }          
        }           
    }



 /*
    *Same as 1, 2, and 3, however after hard constraints are considered, system prioritises any specified 
    *numbers of employees required on any day entered under optional settings. So if on Monday, 7 staff are 
    *required then this will take precedence over prefered days off and consecutive working days (or soft constraints).
    *If no employees are set on a particular day under optional settings then the system will prioritising soft constraints while 
    *attempting to assign an even number of shifts across the week/period.
    *
    *Random dates and random employees are chosen now for each allocation of shift to ensure a fair allocation.
    *Shifts are now evenly placed once per iteration proportionally and incrementally over the period rather than all required shifts per day 
    *being placed on that iteration. This minimises shifts running out before the end of the random loops
    *
    *Current system compared with a dataset benchmarked optimized system and acheives comparable results with less penalty violations.
    */
    @FXML
    private void automatedShifts6() throws ClassNotFoundException, SQLException, ParseException{
        
        //variables for the start and end dates of chosen schedule period
        LocalDate startDate = scheduleFromDate.getValue();
        LocalDate endDate = scheduleToDate.getValue(); 
        
        //variable for the selected shift pattern
        int shiftPattern = shiftPatternComboBox.getSelectionModel().getSelectedIndex()+1;
        
        //variable for the selected shift type
        int shiftType =  shiftTypeComboBox.getSelectionModel().getSelectedIndex()+1;
        
        //start and end times for chosen shift period
        LocalTime startTime = LocalTime.of(Integer.parseInt(startTimeHours.getSelectionModel().getSelectedItem()), Integer.parseInt(startTimeMinutes.getSelectionModel().getSelectedItem()));
        LocalTime finishTime = LocalTime.of(Integer.parseInt(finishTimeHours.getSelectionModel().getSelectedItem()), Integer.parseInt(finishTimeMinutes.getSelectionModel().getSelectedItem()));
        
        //variable for days between start and end dates for the selected schedule period
        long schedulePeriod = ChronoUnit.DAYS.between(startDate, endDate)+1;
        
        int totalHours =0;
        double totalMinutes =0;
                
        //variable for total number of hours in a assigned/selected shift
        totalHours = Duration.ofHours(24).plus(Duration.between(startTime, finishTime)).toHoursPart();           
        //variable for the minutes part of a assigned/selected shift. For example 8 hours and 15 minutes. This value would be 15 minutes.
        totalMinutes = Double.parseDouble(df.format((Duration.between(startTime, finishTime).toMinutesPart())*0.0166));        
        
        //variable for total duration of a assigned shift
        double totalDuration = totalHours + totalMinutes;
        
        //variable shift cost value
        double shiftCost;
        
        //variable for holding the number of hours assigned to an employee in a week to evaluate for not exceeding the weekly contracted hours.
        double assignedHours1;
        
        double hoursRequired = 0; //required hours by shift planner
        double maxAvailableHours = 0.0; //max available hours based on slected staff and their contrcated hours
        double averageEmployeesPossible = 0; //average of employeess possible per day in a week based on available hours
        double remainingEmployees = 0;//remainder from the average result to add onto random days
        int weekdays = 7;
        
       try{
        //validation check the user has selected at least one employee    
        if(selectedEmployeesTable.getItems().isEmpty()){
            
            Alert noSelection = new Alert(Alert.AlertType.ERROR);
            noSelection.setHeaderText("Please choose an employee or employees to allocate shifts");
            noSelection.showAndWait();
        }
        //validation check for ensuring only numbers are entered into the staff required per day under optional settings
        else if((allDaysTick.isSelected() && !allDays.getText().matches("\\d*")) || (monTick.isSelected() && !mon.getText().matches("\\d*")) || (tueTick.isSelected() && !tue.getText().matches("\\d*"))
                || (wedTick.isSelected() && !wed.getText().matches("\\d*")) || (thuTick.isSelected() && !thu.getText().matches("\\d*")) || (friTick.isSelected() && !fri.getText().matches("\\d*"))
                || (satTick.isSelected() && !sat.getText().matches("\\d*")) || (sunTick.isSelected() && !sun.getText().matches("\\d*"))){
            
            Alert numbersOnly = new Alert(Alert.AlertType.ERROR);
            numbersOnly.setHeaderText("Please use whole numbers only for employees required per day under Optional Settings.");
            numbersOnly.showAndWait();
            
        }
        //validation check for ensuring number of staff required per day under optional setiings, is not blank/empty.
        else if(shiftType==1 && ((allDaysTick.isSelected() && allDays.getText().isBlank()) || (monTick.isSelected() && mon.getText().isBlank()) ||
                    (tueTick.isSelected() && tue.getText().isBlank()) || (wedTick.isSelected() && wed.getText().isBlank()) || 
                    (thuTick.isSelected() && thu.getText().isBlank()) || (friTick.isSelected() && fri.getText().isBlank()) ||
                    (satTick.isSelected() && sat.getText().isBlank()) || (sunTick.isSelected() && sun.getText().isBlank()))){
            
            Alert noEmployees = new Alert(Alert.AlertType.ERROR);
            noEmployees.setHeaderText("Please add the number of employees required per day under Optional Settings or untick the selected option.");
            noEmployees.showAndWait();        
        }
        else if(shiftType==1 && ((allDaysTick.isSelected() && Integer.parseInt(allDays.getText())>selectedEmployeesTable.getItems().size()) || 
                (monTick.isSelected() && Integer.parseInt(mon.getText())>selectedEmployeesTable.getItems().size()) || 
                (tueTick.isSelected() && Integer.parseInt(tue.getText())>selectedEmployeesTable.getItems().size()) ||
                (wedTick.isSelected() && Integer.parseInt(wed.getText())>selectedEmployeesTable.getItems().size()) || 
                (thuTick.isSelected() && Integer.parseInt(thu.getText())>selectedEmployeesTable.getItems().size()) || 
                (friTick.isSelected() && Integer.parseInt(fri.getText())>selectedEmployeesTable.getItems().size()) ||
                (satTick.isSelected() && Integer.parseInt(sat.getText())>selectedEmployeesTable.getItems().size()) || 
                (sunTick.isSelected() && Integer.parseInt(sun.getText())>selectedEmployeesTable.getItems().size()))){
            
            Alert tooManyEmployees = new Alert(Alert.AlertType.ERROR);
            tooManyEmployees.setHeaderText("The required number of employees per day must be lower than the number of employees selected/available ("+selectedEmployeesTable.getItems().size()+")");
            tooManyEmployees.showAndWait();   
            
        } 
        else if(shiftType==1 && allDaysTick.isSelected() && Integer.parseInt(allDays.getText())==0){
            
            Alert tooManyEmployees = new Alert(Alert.AlertType.ERROR);
            tooManyEmployees.setHeaderText("This will create 0 shifts for all days. Please add at least 1 employee or untick the All Days tick box.");
            tooManyEmployees.showAndWait();
        }
        else{                              
            Alert createShiftConfirmation = new Alert(Alert.AlertType.CONFIRMATION);
            createShiftConfirmation.setHeaderText("Are you sure you want to create shifts automatically for the selected period, employees and settings?");
            createShiftConfirmation.showAndWait();

            if(createShiftConfirmation.getResult().getText().equalsIgnoreCase("OK")){
                                        
                    LocalDate scheduleDate = scheduleFromDate.getValue(); //set date variable as the first date in the selected shedule period                
                    ArrayList<LocalDate> dates = new ArrayList<>();//these are priority dates if selected by the shift planner under optional settings unless all are selected
                    ArrayList<LocalDate> dates2 = new ArrayList<>();//these will be randomised and less prioritised                                                               
                    
                    employeesSelected.addAll(selectedEmployeesTable.getItems()); //get the employees and add to an ArrayList                 
                    Collections.shuffle(employeesSelected);//randomise order of employees so a fair distribution of shifts can be acheived                 
                    employeesSelected2.addAll(selectedEmployeesTable.getItems()); //a copy of the list to be shuffled later and used in other search loops  

                    //retreive the maximum available hours for a week from the staff selected and their contracted hours
                    for (Employee employee : employeesSelected){                             
                        
                        maxAvailableHours = maxAvailableHours + DAO.getContractedHours(Integer.parseInt(employee.getEmployeeID()));
                          
                       }
                    
                    //get the average number of employees available per day in a week from the staff available and using the duration of each shift required
                    averageEmployeesPossible = Math.floor((maxAvailableHours/7)/totalDuration);                            
                    //retreive total of lost remainders during rounding numbers which may total more than one employee, which will need to be added onto a random day
                    remainingEmployees = Math.round((maxAvailableHours-((averageEmployeesPossible*7)*totalDuration))/totalDuration);
                    

                    ObservableList<CheckBox> daysTickBoxes = FXCollections.observableArrayList(monTick, tueTick, wedTick, thuTick, friTick, satTick, sunTick);//to store tickboxes
                    ObservableList<TextField> dayTextFields = FXCollections.observableArrayList(mon, tue, wed, thu, fri, sat, sun);//to store tickboxes
                    ObservableList<TextField> dayTextFields1 = FXCollections.observableArrayList(mon, tue, wed, thu, fri, sat, sun);//to iterate textfields
                    ObservableList<TextField> priorityDayTextFields = FXCollections.observableArrayList();//to record priority days
                                        
                    int employees = (int) averageEmployeesPossible;//converted rounded double values to integers to wok better with parsing textfields later                    
                    int intRemainder1 = 0;
     
                //if no optional days (including all days tickbox) are selected (ticked), then set all days in the selected schedule to be allocated to the closest as possible, 
                //an average number of employees per day. Any remaining employees (from rounding averages) will be addedd randomly to random days.          
                if(shiftType==1 && (!allDaysTick.isSelected() && !monTick.isSelected() && !tueTick.isSelected() && !wedTick.isSelected() && !thuTick.isSelected() &&
                         !friTick.isSelected() && !satTick.isSelected() && !sunTick.isSelected())){                                        

                    for (CheckBox dayTick: daysTickBoxes){                        
                        dayTick.setSelected(true);
                    }                                        
                                        
                    for (TextField day : dayTextFields){                        
                           day.setText(String.valueOf(employees));//else assign average employees on remaining random days in the week
                    }     
                                                                             
                }
                
                //if all days is selected then check if the hours required are over the hours available and if so then average the hours between all days
                else if(shiftType==1 && allDaysTick.isSelected()){  
                                                 
                //get hours requested
                hoursRequired = (Double.parseDouble(allDays.getText())*7)*totalDuration;                                                                         
                    
                  if(hoursRequired>=maxAvailableHours){
                        
                        allDaysTick.setSelected(false);
                        allDaysTick.setDisable(true);
                        allDays.clear();
                        allDays.setDisable(true);
                        
                        //will use the days to average the shift allocations 
                        for (CheckBox dayTick: daysTickBoxes){                        
                        dayTick.setSelected(true);
                        }                                                                                                         
                                                
                        for (TextField day : dayTextFields){                        
                            day.setText(String.valueOf(employees));//else assign average employees on remaining random days in the week                                        
                        }                            
                    }                   
                    //if under the available hours are required - evenly ditributes shifts using an average                 
                    else{                                                                                                
                        //will use the days to average the shift allocations 
                        for (CheckBox dayTick: daysTickBoxes){                        
                        dayTick.setSelected(true);
                        }                                                                                                         
                                                
                        for (TextField day : dayTextFields){                        
                            day.setText(String.valueOf(allDays.getText()));//else assign average employees on remaining random days in the week                                        
                        }  
                        
                        allDaysTick.setSelected(false);
                        allDaysTick.setDisable(true);
                        allDays.clear();
                        allDays.setDisable(true);                                                    
                    }
                   
                 }
                       
                int employeesRequired = 0;//will be used later to calculate a multiplier
                hoursRequired = 0;
                
                 if(shiftType==1 && (monTick.isSelected() || tueTick.isSelected() || wedTick.isSelected() || thuTick.isSelected() ||
                     friTick.isSelected() || satTick.isSelected() || sunTick.isSelected())){  

                    
                    int sublist = 0;//index counter for randomising (later) dates which are not selected under optional settings 
                    
                    //this loop will ensure that any days selected under optional settings by the shift planner will be prioritised for allocating shifts against non-selected days                                           
                                        
                    if (monTick.isSelected() && Integer.parseInt(mon.getText())>0){                        
                             hoursRequired = hoursRequired + Integer.parseInt(mon.getText())*totalDuration;
                                employeesRequired = employeesRequired + Integer.parseInt(mon.getText());
                    }
                    if (tueTick.isSelected() && Integer.parseInt(tue.getText())>0){
                        
                             hoursRequired = hoursRequired + Integer.parseInt(tue.getText())*totalDuration;
                                employeesRequired = employeesRequired + Integer.parseInt(tue.getText());
                    }
                    if (wedTick.isSelected() && Integer.parseInt(wed.getText())>0){
                        
                             hoursRequired = hoursRequired + Integer.parseInt(wed.getText())*totalDuration;
                                employeesRequired = employeesRequired + Integer.parseInt(wed.getText());
                    }
                    if (thuTick.isSelected() && Integer.parseInt(thu.getText())>0){
                        
                             hoursRequired = hoursRequired + Integer.parseInt(thu.getText())*totalDuration;
                                employeesRequired = employeesRequired + Integer.parseInt(thu.getText());
                    }
                    if (friTick.isSelected() && Integer.parseInt(fri.getText())>0){
                        
                             hoursRequired = hoursRequired + Integer.parseInt(fri.getText())*totalDuration;
                                employeesRequired = employeesRequired + Integer.parseInt(fri.getText());
                    }
                    if (satTick.isSelected() && Integer.parseInt(sat.getText())>0){
                        
                             hoursRequired = hoursRequired + Integer.parseInt(sat.getText())*totalDuration;
                                employeesRequired = employeesRequired + Integer.parseInt(sat.getText());
                    }
                    if (sunTick.isSelected() && Integer.parseInt(sun.getText())>0){
                        
                             hoursRequired = hoursRequired + Integer.parseInt(sun.getText())*totalDuration;
                                employeesRequired = employeesRequired + Integer.parseInt(sun.getText());
                    }                                        
                  
                    for (int i=0; i<schedulePeriod; i++){
                      
                        if (scheduleDate.getDayOfWeek().getValue()==1 && (monTick.isSelected() && Integer.parseInt(mon.getText())>0)){
                            
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1;                                                        
                        }
                        else if(scheduleDate.getDayOfWeek().getValue()==2 && (tueTick.isSelected() && Integer.parseInt(tue.getText())>0)){
                            
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1; 
                        }  
                        else if(scheduleDate.getDayOfWeek().getValue()==3 && (wedTick.isSelected() && Integer.parseInt(wed.getText())>0)){
                            
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1; 
                        }
                        else if(scheduleDate.getDayOfWeek().getValue()==4 && (thuTick.isSelected() && Integer.parseInt(thu.getText())>0)){
                            
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1; 
                        }
                        else if(scheduleDate.getDayOfWeek().getValue()==5 && (friTick.isSelected() && Integer.parseInt(fri.getText())>0)){
                            
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1; 
                        }
                        else if(scheduleDate.getDayOfWeek().getValue()==6 && (satTick.isSelected() && Integer.parseInt(sat.getText())>0)){
                            
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1; 
                        }
                        else if(scheduleDate.getDayOfWeek().getValue()==7 && (sunTick.isSelected() && Integer.parseInt(sun.getText())>0)){
                                                        
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1; 
                        }
                        else{
                            dates2.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                        }                        
                    }                                      
                    Collections.shuffle(dates);//randomise these priority dates first 
                    
                    if(dates2.isEmpty()==false){
                        dates.addAll(dates2); //then add the lesser priority dates                                                                 
                        Collections.shuffle(dates.subList(sublist, dates.size()));//finally randomise the lesser priority dates from index sublist
                    }
                    
                    if(monTick.isSelected()==false || tueTick.isSelected()==false || wedTick.isSelected()==false || thuTick.isSelected()==false ||
                            friTick.isSelected()==false || satTick.isSelected()==false || sunTick.isSelected()==false){

                        double nonTickedDays = Math.round(((maxAvailableHours-hoursRequired)/totalDuration)/(7-sublist));
                        int intNonTickedAllocation = (int) nonTickedDays;

                        if (monTick.isSelected()==false){
                            mon.setText(String.valueOf(intNonTickedAllocation));
                            hoursRequired = hoursRequired + Integer.parseInt(mon.getText())*totalDuration;
                            employeesRequired = employeesRequired + Integer.parseInt(mon.getText());
                        }
                        if (tueTick.isSelected()==false){
                            tue.setText(String.valueOf(intNonTickedAllocation));
                            hoursRequired = hoursRequired + Integer.parseInt(tue.getText())*totalDuration;
                            employeesRequired = employeesRequired + Integer.parseInt(tue.getText());
                        }
                        if (wedTick.isSelected()==false){
                            wed.setText(String.valueOf(intNonTickedAllocation));
                            hoursRequired = hoursRequired + Integer.parseInt(wed.getText())*totalDuration;
                            employeesRequired = employeesRequired + Integer.parseInt(wed.getText());
                        }
                        if (thuTick.isSelected()==false){
                            thu.setText(String.valueOf(intNonTickedAllocation));
                            hoursRequired = hoursRequired + Integer.parseInt(thu.getText())*totalDuration;
                            employeesRequired = employeesRequired + Integer.parseInt(thu.getText());
                        }
                        if (friTick.isSelected()==false){
                            fri.setText(String.valueOf(intNonTickedAllocation));
                            hoursRequired = hoursRequired + Integer.parseInt(fri.getText())*totalDuration;
                            employeesRequired = employeesRequired + Integer.parseInt(fri.getText());
                        }
                        if (satTick.isSelected()==false){
                            sat.setText(String.valueOf(intNonTickedAllocation));
                            hoursRequired = hoursRequired + Integer.parseInt(sat.getText())*totalDuration;
                            employeesRequired = employeesRequired + Integer.parseInt(sat.getText());
                        }
                        if (sunTick.isSelected()==false){
                            sun.setText(String.valueOf(intNonTickedAllocation));
                            hoursRequired = hoursRequired + Integer.parseInt(sun.getText())*totalDuration;
                            employeesRequired = employeesRequired + Integer.parseInt(sun.getText());
                        }
                    }
                    
                 }
                    
                    //if hours required are higher than those available then first, we need to adjust (by reduction) all 
                    //of the required employees set by the shift planner, proportionally down to below the available hours so they can be allocated approrpiately.  
                 if(hoursRequired>=maxAvailableHours){  
                   
                    double multiplier = maxAvailableHours/employeesRequired;
                    double newValue = 0;                       
                    int intNewValue = 0; 
                    int totalAllocated = 0;                                           
                    
                    for(TextField day : dayTextFields1){ 

                        if (day.isDisabled()==false && Integer.parseInt(day.getText())>0){

                            if(day.equals(mon)){
                                monOldValue = Integer.parseInt(mon.getText());
                                newValue = (Integer.parseInt(mon.getText())*multiplier)/totalDuration;
                                intNewValue = (int) newValue;
                                mon.setText(String.valueOf(intNewValue));
                                totalAllocated = totalAllocated + intNewValue;
                                priorityDayTextFields.add(mon);

                            }
                            else if(day.equals(tue)){
                                tueOldValue = Integer.parseInt(tue.getText());
                                newValue = (Integer.parseInt(tue.getText())*multiplier)/totalDuration;
                                intNewValue = (int) newValue;
                                tue.setText(String.valueOf(intNewValue));
                                totalAllocated = totalAllocated + intNewValue;
                                priorityDayTextFields.add(tue);

                            }
                            else if(day.equals(wed)){
                               wedOldValue = Integer.parseInt(wed.getText());
                               newValue = (Integer.parseInt(wed.getText())*multiplier)/totalDuration;
                                intNewValue = (int) newValue;
                                wed.setText(String.valueOf(intNewValue));
                                totalAllocated = totalAllocated + intNewValue;
                                priorityDayTextFields.add(wed);

                            }
                            else if(day.equals(thu)){
                                thuOldValue = Integer.parseInt(thu.getText());
                                newValue = (Integer.parseInt(thu.getText())*multiplier)/totalDuration;
                                intNewValue = (int) newValue;
                                thu.setText(String.valueOf(intNewValue));
                                totalAllocated = totalAllocated + intNewValue;
                                priorityDayTextFields.add(thu);

                            }
                            else if(day.equals(fri)){
                                friOldValue = Integer.parseInt(fri.getText());
                                newValue = (Integer.parseInt(fri.getText())*multiplier)/totalDuration;
                                intNewValue = (int) newValue;
                                fri.setText(String.valueOf(intNewValue));
                                totalAllocated = totalAllocated + intNewValue;
                                priorityDayTextFields.add(fri);

                            }
                            else if(day.equals(sat)){
                                satOldValue = Integer.parseInt(sat.getText());
                                newValue = (Integer.parseInt(sat.getText())*multiplier)/totalDuration;
                                intNewValue = (int) newValue;
                                sat.setText(String.valueOf(intNewValue));
                                totalAllocated = totalAllocated + intNewValue;
                                priorityDayTextFields.add(sat);

                            }
                            else if(day.equals(sun)){
                                sunOldValue = Integer.parseInt(sun.getText());
                                newValue = (Integer.parseInt(sun.getText())*multiplier)/totalDuration;
                                intNewValue = (int) newValue;
                                sun.setText(String.valueOf(intNewValue));
                                totalAllocated = totalAllocated + intNewValue;
                                priorityDayTextFields.add(sun);

                            }                                                                                                                                                                                                                       

                        } 
                   }
                    //important - this is for allocating (later) any remaining days from teh rounding down of whole integer shifts
                     double remainder = 0;
                     int intRemainder = 0;
                     
                     remainder = Math.round((maxAvailableHours-(totalAllocated*totalDuration))/totalDuration);
                     intRemainder = (int) remainder;
                     intRemainder1 = intRemainder; //global variable to be used by an outer method                          
                }                   
                 
                if(shiftType>1){
                    for (int i=0; i < schedulePeriod; i++){                        
                        dates.add(scheduleDate);
                        scheduleDate = scheduleDate.plusDays(1);
                    }
                } 
                 
                //for each day in the schedule period
                //for (int i=0; i < schedulePeriod; i++){
                for (LocalDate date : dates){     
                    Collections.shuffle(employeesSelected);//randomise employees per day
                                                                
                      //for each employee selected for the projected schedule period  
                      for (Employee employee : employeesSelected){
                          
                        if(shiftType>1){

                            if(allDaysTick.isSelected() || (!monTick.isSelected() && !tueTick.isSelected() && !wedTick.isSelected() && !thuTick.isSelected()
                                    && !friTick.isSelected() && !satTick.isSelected() && !sunTick.isSelected()) ){

                             DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, shiftType, 0);
                             continue;
                            }
                            else if(date.getDayOfWeek().getValue()==1 && monTick.isSelected() || date.getDayOfWeek().getValue()==2 && tueTick.isSelected() ||
                                    date.getDayOfWeek().getValue()==3 && wedTick.isSelected() || date.getDayOfWeek().getValue()==4 && thuTick.isSelected() ||
                                    date.getDayOfWeek().getValue()==5 && friTick.isSelected() || date.getDayOfWeek().getValue()==6 && satTick.isSelected() ||
                                    date.getDayOfWeek().getValue()==7 && sunTick.isSelected()){

                                DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, shiftType, 0);
                                continue;
                            }
                            else{
                                continue;
                            }
                         }
                          
                        //get number of working shifts currently assigned on this day
                        int numOfShiftsOnDay = DAO.getNumOfShiftsOnDay(date.format(formatter)); 
                        int numOfShiftsOnDayAdded = 0;
                          
                        //set weekly assigned/allocated hours counter to 0  
                        assignedHours1=0;                                               
                        
                        //get and store employee contract from database as we will need this for contract constraint checks
                        Contract contract = DAO.getContract(employee.getEmployeeContract());
                        
                        //store shift cost for each shift that will be created, based on the hourly rate from the employee contract multiplied by the 
                        //duration of hours for the selected shift. This figure will be used at the point of assigning a shift.
                        shiftCost = Double.parseDouble(df.format((DAO.getHourlyRate(employee.getEmployeeID())) * totalDuration));                                   
                           
                        //hard constraint - check that the current employee contract end date has not passed the current day in the schedule period                     
                        if(!(date.isAfter(LocalDate.parse(contract.getContractEndDate())))){
                                                                    
                        /*The following block of code then gets current number of working hours already assigned for the current employee, for the current week of current day
                        *of the projected schedule period.
                        */
                        //first set variables for finding the current whole week (mon-sun)in the chosen schedule period and setting the start and end dates for this week
                        LocalDate startOfWeek = date.with(DayOfWeek.MONDAY);
                        LocalDate endOfWeek = date.with(DayOfWeek.SUNDAY);
                        //sets period of days to iterate through to check for existing shifts
                        long weekPeriod = startOfWeek.until(endOfWeek, DAYS)+1;

                        LocalDate day = startOfWeek;

                            //for each day of the first week in the projected schedule period
                            for (int a=0; a < weekPeriod; a++){                            

                                //check if there are any existing shifts assigned
                                if(DAO.checkEmployeeShift(employee.getEmployeeID(), day.format(formatter))==true){                                                                              

                                    //get the shift if it exists
                                    Shift shift = DAO.getEmployeeShift(employee.getEmployeeID(), day.format(formatter));

                                    //then check that this is a working shift using the shift type
                                    if(shift.getShiftType().equalsIgnoreCase("1")){

                                    //if working shift then get the duration of hours and minutes for that shift    
                                    LocalTime shiftStart = LocalTime.parse(shift.getShiftStart());
                                    LocalTime shiftEnd = LocalTime.parse(shift.getShiftEnd());
                                    int hours1 = Duration.ofHours(24).plus(Duration.between(shiftStart, shiftEnd)).toHoursPart();
                                    double minutes1 = Double.parseDouble(df.format((Duration.between(shiftStart, shiftEnd).toMinutesPart())*0.0166)); 
                                    double duration1 = hours1 + minutes1;
                                    //set a variable for the day to 0 to store this duration
                                    double assignedHours2 = 0;

                                    //adds the duration to the day variable 
                                    assignedHours2 = Double.sum(assignedHours2, duration1);

                                    //passes the duration to a running total for the week
                                    assignedHours1 = Double.sum(assignedHours1, assignedHours2);  
                                    }
                                 }                                                                                                                                               
                                //increment a day and continue the loop to get all assigned hours for that week 
                                day = day.plusDays(1);
                            }//end of calculating working hours for the week                                      
                                                      
                            //hard constraint - now ensures the contracted weekly hours for the current employee will not been exceeded - if exceeded then will assign day off
                            if (!(Double.sum(assignedHours1, totalDuration) > Double.parseDouble(contract.getContractedHours()))){                                
                                                                                             
                                /*hard constraint (sick days, annual leave, etc) - check if the current employee has a shift or any time-off booked already on 
                                * the current date of the schedule period and if does, then to skip this day. 
                                */
                                if(!(DAO.checkEmployeeShift(employee.getEmployeeID(), date.format(formatter))==true)){
                                                                         
                                     /*hard constraint - the following block checks if the employee has a shift booked the day before the current date as if does, will need to check the constraint 
                                     * for minimum hours between shifts has not been exceeded                        
                                     */
                                     
                                     //check if a shift exists the day before this day
                                     if(DAO.checkEmployeeShift(employee.getEmployeeID(), date.minusDays(1).format(formatter))==true){
                                         
                                        //if the above is true, then get the shift
                                        Shift shift2 = DAO.getEmployeeShift(employee.getEmployeeID(), date.minusDays(1).format(formatter));
                                       
                                        //now check if the shift is a working shift  
                                        if(shift2.getShiftType().equalsIgnoreCase("1")){
                                           
                                         //if working shift - get the duration between the end of this shift and the beginning of the proposed shift as none working shifts would have zero duration                                          
                                         LocalTime shiftEnd = LocalTime.parse(shift2.getShiftEnd());
                                         LocalTime shiftStart = startTime;
                                         int hours2 = Duration.ofHours(24).plus(Duration.between(shiftEnd, shiftStart)).toHoursPart();
                                         double minutes2 = Double.parseDouble(df.format((Duration.between(shiftEnd, shiftStart).toMinutesPart())*0.0166));
                                         double duration2 = hours2 + minutes2;
                                                                                  
                                                                     
                                            //hard constraint - now check that minimum hours between shifts as stated in the employee contract has not been exceeded
                                            if(duration2 >= Double.parseDouble(contract.getMinHoursBetweenShifts())){                                               

                                                //Now hard constraints checks finished consider any demands set by shift planner (staff required per day) and all soft constraints                                                                                               
                                                  
                                                //check that the number of currently assigned shifts have not exceeded the limit set under optional settings for the current day - if optinal settings are set
                                                if( ((date.getDayOfWeek().getValue()==1) && (Integer.parseInt(mon.getText())>numOfShiftsOnDay)) || 
                                                    ((date.getDayOfWeek().getValue()==2) && (Integer.parseInt(tue.getText())>numOfShiftsOnDay)) ||
                                                    ((date.getDayOfWeek().getValue()==3) && (Integer.parseInt(wed.getText())>numOfShiftsOnDay)) ||
                                                    ((date.getDayOfWeek().getValue()==4) && (Integer.parseInt(thu.getText())>numOfShiftsOnDay)) ||
                                                    ((date.getDayOfWeek().getValue()==5) && (Integer.parseInt(fri.getText())>numOfShiftsOnDay)) ||
                                                    ((date.getDayOfWeek().getValue()==6) && (Integer.parseInt(sat.getText())>numOfShiftsOnDay)) ||
                                                    ((date.getDayOfWeek().getValue()==7) && (Integer.parseInt(sun.getText())>numOfShiftsOnDay)) ){                                                       
                                                    
                                                 
         //////////////////////                        //get consecutive days/shifts count for current employee (soft constraint check)            
                                                       int consDays1 = Integer.parseInt(contract.getMaxConsWorkDays());
                                                       LocalDate startConsDays1 = date.minusDays(consDays1); 
                                                       int consShifts1 = 0;
                                                       
                                                       for (int b=0; b < consDays1; b++){
                                                        try{
                                                                Shift shift3 = DAO.getEmployeeShift(employee.getEmployeeID(), startConsDays1.format(formatter));
                                                                if (shift3.getShiftType().equalsIgnoreCase("1")){
                                                                    consShifts1 = consShifts1 + 1;
                                                                }                                                           
                                                            }
                                                        catch(NullPointerException s){
                                                                }
                                                        startConsDays1 = startConsDays1.plusDays(1);
                                                       }                                                                                                  
                                                    
                                                    /*
                                                    * Soft constraint checks
                                                    * if either of the current employee's preferred days off are on this weekday or consecutive days are reached 
                                                    * then look for another employee who would better suit this day
                                                    */
                                                    if (Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                        Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                        consShifts1 >= Integer.parseInt(contract.getMaxConsWorkDays())){                                                                                                          
                                      
                                                        
                                                        Collections.shuffle(employeesSelected2);
                                                        //Now we will check if any other employees are available instead - will aim to find the next available only
                                                        for (Employee employee1 : employeesSelected2){
                                                            
                                                            //set assigned/allocated hours count to 0  
                                                            double assignedHours3=0;

                                                            //get and store employee contract (in this current loop) from database as we will need this for contract constraint checks
                                                            Contract contract1 = DAO.getContract(employee1.getEmployeeContract());

                                                            //store shift cost for the shift that will be created
                                                            double shiftCost1 = Double.parseDouble(df.format((DAO.getHourlyRate(employee1.getEmployeeID())) * totalDuration));                                   

                                                            //hard constraint - check that the current employee contract end date has not passed the current day in the schedule period                     
                                                            if(!(date.isAfter(LocalDate.parse(contract1.getContractEndDate())))){

                                                            //The following block of code then gets current number of working hours already assigned for the current employee
                                                            
                                                                //first set variables for finding the current whole week (mon-sun)in the chosen schedule period and setting the start and end dates for this week
                                                                LocalDate startOfWeek1 = date.with(DayOfWeek.MONDAY);
                                                                LocalDate endOfWeek1 = date.with(DayOfWeek.SUNDAY);
                                                                //sets period of days to iterate through to check for existing shifts
                                                                long weekPeriod1 = startOfWeek1.until(endOfWeek1, DAYS)+1;

                                                                LocalDate day1 = startOfWeek1;

                                                                    //for each day of the week in the projected schedule period
                                                                    for (int b=0; b < weekPeriod1; b++){                            

                                                                        //check if there are any existing shifts assigned
                                                                        if(DAO.checkEmployeeShift(employee1.getEmployeeID(), day1.format(formatter))==true){                                                                              

                                                                            //get the shift if it exists
                                                                            Shift shift1 = DAO.getEmployeeShift(employee1.getEmployeeID(), day1.format(formatter));

                                                                            //then check that this is a working shift using the shift type
                                                                            if(shift1.getShiftType().equalsIgnoreCase("1")){

                                                                                //if working shift then get the duration of hours and minutes for that shift    
                                                                                LocalTime shiftStart1 = LocalTime.parse(shift1.getShiftStart());
                                                                                LocalTime shiftEnd1 = LocalTime.parse(shift1.getShiftEnd());
                                                                                int hours3 = Duration.ofHours(24).plus(Duration.between(shiftStart1, shiftEnd1)).toHoursPart();
                                                                                double minutes3 = Double.parseDouble(df.format((Duration.between(shiftStart1, shiftEnd1).toMinutesPart())*0.0166)); 
                                                                                double duration3 = hours3 + minutes3;
                                                                                //set a variable for the day to 0 to store this duration
                                                                                double assignedHours4 = 0;

                                                                                //adds the duration to the day variable 
                                                                                assignedHours4 = Double.sum(assignedHours4, duration3);

                                                                                //passes the duration to a running total for the week
                                                                                assignedHours3 = Double.sum(assignedHours3, assignedHours4);  
                                                                            }
                                                                         }                                                                                                                                               
                                                                        //increment a day and continue the loop to get all assigned hours for that week 
                                                                        day1 = day1.plusDays(1);
                                                                    }//end of calculating working hours for the week                                      


                                                                    //hard constraint - now ensures the contracted weekly hours for the current employee will not been exceeded - if exceeded then will assign day off
                                                                    if (!(Double.sum(assignedHours3, totalDuration) > Double.parseDouble(contract1.getContractedHours()))){

                                                                        /*hard constraint (sick days, annual leave, etc) - check if the current employee has a shift or any time-off booked already on 
                                                                        * the current date of the schedule period and if does, then to skip this day. 
                                                                        */
                                                                        if(!(DAO.checkEmployeeShift(employee1.getEmployeeID(), date.format(formatter))==true)){

                                                                             /*hard constraint - the following block checks if the employee has a shift booked the day before the current date as if does, will need to check the constraint 
                                                                             * for minimum hours between shifts has not been exceeded                        
                                                                             */

                                                                         //check if a shift exists the day before this day
                                                                         if(DAO.checkEmployeeShift(employee1.getEmployeeID(), date.minusDays(1).format(formatter))==true){

                                                                             //if the above is true, then get the shift
                                                                             Shift shift3 = DAO.getEmployeeShift(employee1.getEmployeeID(), date.minusDays(1).format(formatter));

                                                                            //now check if the shift is a working shift  
                                                                            if(shift3.getShiftType().equalsIgnoreCase("1")){

                                                                             //if working shift - get the duration between the end of this shift and the beginning of the proposed shift                                          
                                                                             LocalTime shiftEnd1 = LocalTime.parse(shift3.getShiftEnd());
                                                                             LocalTime shiftStart1 = startTime;
                                                                             int hours3 = Duration.ofHours(24).plus(Duration.between(shiftEnd1, shiftStart1)).toHoursPart();
                                                                             double minutes3 = Double.parseDouble(df.format((Duration.between(shiftEnd1, shiftStart1).toMinutesPart())*0.0166));
                                                                             double duration3 = hours3 + minutes3;


                                                                                //hard constraint - now check that minimum hours between shifts as stated in the employee contract has not been exceeded
                                                                                if(duration3 >= Double.parseDouble(contract1.getMinHoursBetweenShifts())){
                                                                                    
                                                                                    //before assigning the shift check for consecutive working days (soft constraint) before this date                                                                  
                                                                                           int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                                           LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                                           int consShifts2 = 0;
                                                                                           for (int c=0; c < consDays2; c++){
                                                                                            try{
                                                                                                    Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                                    if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                                        consShifts2 = consShifts2 + 1;
                                                                                                    }                                                           
                                                                                                }
                                                                                            catch(NullPointerException s){
                                                                                                    }
                                                                                            startConsDays2 = startConsDays2.plusDays(1);
                                                                                           }
                                                                                    //System.out.println("employee1 at line: 1785 "+employee1.getEmployeeName());
                                                                                    if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                            Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                            consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){
                                                                                                                                                                                                                               
                                                                                                //assign the working shift
                                                                                                DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);
         
                                                                                                //get updated number of working shifts currently assigned on this day
                                                                                                numOfShiftsOnDayAdded = numOfShiftsOnDayAdded +1;
                                                                                                break;                                                                                                                                                                                                                                                                                                
                                                                                      }                                                                                    
                                                                                 }                                                        
                                                                              }
                                                                            else{
                                                                                //System.out.println("employee1 at line: 1803 "+employee1.getEmployeeName());
                                                                                //before assigning the shift check for consecutive working days (soft constraint) before this date                                                                  
                                                                               int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                               LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                               int consShifts2 = 0;
                                                                               for (int c=0; c < consDays2; c++){
                                                                                try{
                                                                                        Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                        if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                            consShifts2 = consShifts2 + 1;
                                                                                        }                                                           
                                                                                    }
                                                                                catch(NullPointerException s){
                                                                                        }
                                                                                startConsDays2 = startConsDays2.plusDays(1);
                                                                               }
                                                                               
                                                                               if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                    Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                    consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){
                                                                                                                                                                                                                               
                                                                                        //assign the working shift
                                                                                        DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);
                                                                                        numOfShiftsOnDayAdded = numOfShiftsOnDayAdded +1;
                                                                                        break;                                                                                                                                                                                                                                                                           
                                                                                }
                                                                            }
                                                                         }
                                                                         else{
                                                                                //System.out.println("employee1 at line: 1838 "+employee1.getEmployeeName());
                                                                                //before assigning the shift check for consecutive working days (soft constraint) before this date                                                                  
                                                                               int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                               LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                               int consShifts2 = 0;
                                                                               for (int c=0; c < consDays2; c++){
                                                                                try{
                                                                                        Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                        if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                            consShifts2 = consShifts2 + 1;
                                                                                        }                                                           
                                                                                    }
                                                                                catch(NullPointerException s){
                                                                                        }
                                                                                startConsDays2 = startConsDays2.plusDays(1);
                                                                               }
                                                                               
                                                                               if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                    Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                    consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){
                                                                                                                                                                                                                               
                                                                                        //assign the working shift
                                                                                         DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);                                                                                                                                                               
                                                                                         
                                                                                         //get updated number of working shifts currently assigned on this day
                                                                                         numOfShiftsOnDayAdded = numOfShiftsOnDayAdded +1;
                                                                                         break;                                                                                              
                                                                                }
                                                                            }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        if(numOfShiftsOnDayAdded>0){
                                                            break;//move to next day as we want to spread allocation evenly
                                                        }                                                        
                                                    }
                                                    else{
                                                         //assign the working shift
                                                         DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                                                         //System.out.println("Working shift assigned at line 1885 for "+employee.getEmployeeName()+" "+date);
                                                    }                                                
                                                }                                                                                                                                                                                                                                                                   
                                            }                                           
                                        }
                                        else{
                                                //check that the number of currently assigned shifts have not exceeded the limit set under optional settings for the current day
                                                if( ((date.getDayOfWeek().getValue()==1) && (Integer.parseInt(mon.getText())>numOfShiftsOnDay)) || 
                                                    ((date.getDayOfWeek().getValue()==2) && (Integer.parseInt(tue.getText())>numOfShiftsOnDay)) ||
                                                    ((date.getDayOfWeek().getValue()==3) && (Integer.parseInt(wed.getText())>numOfShiftsOnDay)) ||
                                                    ((date.getDayOfWeek().getValue()==4) && (Integer.parseInt(thu.getText())>numOfShiftsOnDay)) ||
                                                    ((date.getDayOfWeek().getValue()==5) && (Integer.parseInt(fri.getText())>numOfShiftsOnDay)) ||
                                                    ((date.getDayOfWeek().getValue()==6) && (Integer.parseInt(sat.getText())>numOfShiftsOnDay)) ||
                                                    ((date.getDayOfWeek().getValue()==7) && (Integer.parseInt(sun.getText())>numOfShiftsOnDay)) ){ 
                                                                                                          
         //////////////////////                                           
                                                       int consDays1 = Integer.parseInt(contract.getMaxConsWorkDays());
                                                       LocalDate startConsDays1 = date.minusDays(consDays1); 
                                                       int consShifts1 = 0;
                                                       
                                                       for (int b=0; b < consDays1; b++){
                                                        try{
                                                                Shift shift3 = DAO.getEmployeeShift(employee.getEmployeeID(), startConsDays1.format(formatter));
                                                                if (shift3.getShiftType().equalsIgnoreCase("1")){
                                                                    consShifts1 = consShifts1 + 1;
                                                                }                                                           
                                                            }
                                                        catch(NullPointerException s){
                                                                }
                                                        startConsDays1 = startConsDays1.plusDays(1);
                                                       }                                                                                                  
                                                    
                                                    /*if either of the current employee's preferred days off are on this weekday or consecutive days are reached 
                                                    * then look for another employee who may not prefer to be off on this day
                                                    */
                                                    if (Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                            Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                            consShifts1 >= Integer.parseInt(contract.getMaxConsWorkDays())){                                                                                                          
                                                        
                                                        Collections.shuffle(employeesSelected2);
                                                        //Now we will check if any other employees are available instead - will find the next available only
                                                        for (Employee employee1 : employeesSelected2){
                                                            
                                                            //set assigned/allocated hours count to 0  
                                                            double assignedHours3=0;

                                                            //get and store employee contract (in this current loop) from database as we will need this for contract constraint checks
                                                            Contract contract1 = DAO.getContract(employee1.getEmployeeContract());

                                                            //store shift cost for the shift that will be created
                                                            double shiftCost1 = Double.parseDouble(df.format((DAO.getHourlyRate(employee1.getEmployeeID())) * totalDuration));                                   

                                                            //hard constraint - check that the current employee contract end date has not passed the current day in the schedule period                     
                                                            if(!(date.isAfter(LocalDate.parse(contract1.getContractEndDate())))){

                                                            //The following block of code then gets current number of working hours already assigned for the current employee
                                                            
                                                                //first set variables for finding the current whole week (mon-sun)in the chosen schedule period and setting the start and end dates for this week
                                                                LocalDate startOfWeek1 = date.with(DayOfWeek.MONDAY);
                                                                LocalDate endOfWeek1 = date.with(DayOfWeek.SUNDAY);
                                                                //sets period of days to iterate through to check for existing shifts
                                                                long weekPeriod1 = startOfWeek1.until(endOfWeek1, DAYS)+1;

                                                                LocalDate day1 = startOfWeek1;

                                                                    //for each day of the first week in the projected schedule period
                                                                    for (int b=0; b < weekPeriod1; b++){                            

                                                                        //check if there are any existing shifts assigned
                                                                        if(DAO.checkEmployeeShift(employee1.getEmployeeID(), day1.format(formatter))==true){                                                                              

                                                                            //get the shift if it exists
                                                                            Shift shift1 = DAO.getEmployeeShift(employee1.getEmployeeID(), day1.format(formatter));

                                                                            //then check that this is a working shift using the shift type
                                                                            if(shift1.getShiftType().equalsIgnoreCase("1")){

                                                                                //if working shift then get the duration of hours and minutes for that shift    
                                                                                LocalTime shiftStart1 = LocalTime.parse(shift1.getShiftStart());
                                                                                LocalTime shiftEnd1 = LocalTime.parse(shift1.getShiftEnd());
                                                                                int hours3 = Duration.ofHours(24).plus(Duration.between(shiftStart1, shiftEnd1)).toHoursPart();
                                                                                double minutes3 = Double.parseDouble(df.format((Duration.between(shiftStart1, shiftEnd1).toMinutesPart())*0.0166)); 
                                                                                double duration3 = hours3 + minutes3;
                                                                                //set a variable for the day to 0 to store this duration
                                                                                double assignedHours4 = 0;

                                                                                //adds the duration to the day variable 
                                                                                assignedHours4 = Double.sum(assignedHours4, duration3);

                                                                                //passes the duration to a running total for the week
                                                                                assignedHours3 = Double.sum(assignedHours3, assignedHours4);  
                                                                            }
                                                                         }                                                                                                                                               
                                                                        //increment a day and continue the loop to get all assigned hours for that week 
                                                                        day1 = day1.plusDays(1);
                                                                    }//end of calculating working hours for the week                                      


                                                                    //hard constraint - now ensures the contracted weekly hours for the current employee will not been exceeded - if exceeded then will assign day off
                                                                    if (!(Double.sum(assignedHours3, totalDuration) > Double.parseDouble(contract1.getContractedHours()))){

                                                                        /*hard constraint (sick days, annual leave, etc) - check if the current employee has a shift or any time-off booked already on 
                                                                        * the current date of the schedule period and if does, then to skip this day. 
                                                                        */
                                                                        if(!(DAO.checkEmployeeShift(employee1.getEmployeeID(), date.format(formatter))==true)){

                                                                             /*hard constraint - the following block checks if the employee has a shift booked the day before the current date as if does, will need to check the constraint 
                                                                             * for minimum hours between shifts has not been exceeded                        
                                                                             */

                                                                         //check if a shift exists the day before this day
                                                                         if(DAO.checkEmployeeShift(employee1.getEmployeeID(), date.minusDays(1).format(formatter))==true){

                                                                             //if the above is true, then get the shift
                                                                             Shift shift3 = DAO.getEmployeeShift(employee1.getEmployeeID(), date.minusDays(1).format(formatter));

                                                                            //now check if the shift is a working shift  
                                                                            if(shift3.getShiftType().equalsIgnoreCase("1")){

                                                                             //if working shift - get the duration between the end of this shift and the beginning of the proposed shift                                          
                                                                             LocalTime shiftEnd1 = LocalTime.parse(shift3.getShiftEnd());
                                                                             LocalTime shiftStart1 = startTime;
                                                                             int hours3 = Duration.ofHours(24).plus(Duration.between(shiftEnd1, shiftStart1)).toHoursPart();
                                                                             double minutes3 = Double.parseDouble(df.format((Duration.between(shiftEnd1, shiftStart1).toMinutesPart())*0.0166));
                                                                             double duration3 = hours3 + minutes3;


                                                                                //hard constraint - now check that minimum hours between shifts as stated in the employee contract has not been exceeded
                                                                                if(duration3 >= Double.parseDouble(contract1.getMinHoursBetweenShifts())){
                                                                                    
                                                                                    //before assigning the shift check for consecutive working days (soft constraint) before this date   
                                                                               
                                                                                           int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                                           LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                                           int consShifts2 = 0;
                                                                                           for (int c=0; c < consDays2; c++){
                                                                                            try{
                                                                                                    Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                                    if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                                        consShifts2 = consShifts2 + 1;
                                                                                                    }                                                           
                                                                                                }
                                                                                            catch(NullPointerException s){
                                                                                                    }
                                                                                            startConsDays2 = startConsDays2.plusDays(1);
                                                                                           }
                                                                                    
                                                                                            if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                                Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                                consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){
                                                                                                                                                                                                                               
                                                                                                //assign the working shift
                                                                                                DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);                                                                                                                                                                                             
                                                                                                //update number of working shifts currently assigned on this day
                                                                                                numOfShiftsOnDayAdded = numOfShiftsOnDayAdded +1;
                                                                                                break;                                                                                                
                                                                                    }                                                                                    
                                                                                 }                                                                               
                                                                              }
                                                                            else{
                                                                                 //before assigning the shift check for consecutive working days (soft constraint) before this date   
                                                                               
                                                                                           int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                                           LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                                           int consShifts2 = 0;
                                                                                           for (int c=0; c < consDays2; c++){
                                                                                            try{
                                                                                                    Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                                    if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                                        consShifts2 = consShifts2 + 1;
                                                                                                    }                                                           
                                                                                                }
                                                                                            catch(NullPointerException s){
                                                                                                    }
                                                                                            startConsDays2 = startConsDays2.plusDays(1);
                                                                                           }
                                                                                    
                                                                                            if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                                Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                                consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){
                                                                                                                                                                                                                               
                                                                                                //assign the working shift
                                                                                                DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);                  
                                                                                                //get updated number of working shifts currently assigned on this day
                                                                                                numOfShiftsOnDayAdded = numOfShiftsOnDayAdded +1;
                                                                                                break;
                                                                                            }
                                                                            }
                                                                         }
                                                                         else{
                                                                              //before assigning the shift check for consecutive working days (soft constraint) before this date   

                                                                            int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                            LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                            int consShifts2 = 0;
                                                                            for (int c=0; c < consDays2; c++){
                                                                             try{
                                                                                     Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                     if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                         consShifts2 = consShifts2 + 1;
                                                                                     }                                                           
                                                                                 }
                                                                             catch(NullPointerException s){
                                                                                     }
                                                                             startConsDays2 = startConsDays2.plusDays(1);
                                                                            }

                                                                             if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                 Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                 consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){

                                                                                 //assign the working shift
                                                                                DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);           
                                                                                //get updated number of working shifts currently assigned on this day
                                                                                numOfShiftsOnDayAdded = numOfShiftsOnDayAdded +1;
                                                                                break;
                                                                            }
                                                                         }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        if(numOfShiftsOnDayAdded>0){
                                                            break;//move to next day
                                                        }
                                                    }
                                                    else{
                                                         //assign the working shift
                                                         DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                                                    }
                                                }                                                
                                        }
                                     }
                                     else{
                                         //check that the number of currently assigned shifts have not exceeded the limit set under optional settings for the current day
                                        if( ((date.getDayOfWeek().getValue()==1) && (Integer.parseInt(mon.getText())>numOfShiftsOnDay)) || 
                                            ((date.getDayOfWeek().getValue()==2) && (Integer.parseInt(tue.getText())>numOfShiftsOnDay)) ||
                                            ((date.getDayOfWeek().getValue()==3) && (Integer.parseInt(wed.getText())>numOfShiftsOnDay)) ||
                                            ((date.getDayOfWeek().getValue()==4) && (Integer.parseInt(thu.getText())>numOfShiftsOnDay)) ||
                                            ((date.getDayOfWeek().getValue()==5) && (Integer.parseInt(fri.getText())>numOfShiftsOnDay)) ||
                                            ((date.getDayOfWeek().getValue()==6) && (Integer.parseInt(sat.getText())>numOfShiftsOnDay)) ||
                                            ((date.getDayOfWeek().getValue()==7) && (Integer.parseInt(sun.getText())>numOfShiftsOnDay)) ){ 
                                                                                                          
        /////////////////                        //calculate consecutive days                   
                                                  int consDays1 = Integer.parseInt(contract.getMaxConsWorkDays());
                                                  LocalDate startConsDays1 = date.minusDays(consDays1); 
                                                  int consShifts1 = 0;

                                                  for (int b=0; b < consDays1; b++){
                                                   try{
                                                           Shift shift3 = DAO.getEmployeeShift(employee.getEmployeeID(), startConsDays1.format(formatter));
                                                           if (shift3.getShiftType().equalsIgnoreCase("1")){
                                                               consShifts1 = consShifts1 + 1;
                                                           }                                                           
                                                       }
                                                   catch(NullPointerException s){
                                                           }
                                                   startConsDays1 = startConsDays1.plusDays(1);
                                                  }                                                                                                  
                                                    
                                                    /*if either of the current employee's preferred days off are on this weekday or consecutive days are reached 
                                                    * then look for another employee who may not prefer to be off on this day
                                                    */
                                                    if (Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                        Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                        consShifts1 >= Integer.parseInt(contract.getMaxConsWorkDays())){                                                                                                          
                                      
                                                        Collections.shuffle(employeesSelected2);
                                                        //Now we will check if any other employees are available instead - will find the next available only
                                                        for (Employee employee1 : employeesSelected2){
                                                            
                                                            //set assigned/allocated hours count to 0  
                                                            double assignedHours3=0;

                                                            //get and store employee contract (in this current loop) from database as we will need this for contract constraint checks
                                                            Contract contract1 = DAO.getContract(employee1.getEmployeeContract());

                                                            //store shift cost for the shift that will be created
                                                            double shiftCost1 = Double.parseDouble(df.format((DAO.getHourlyRate(employee1.getEmployeeID())) * totalDuration));                                   

                                                            //hard constraint - check that the current employee contract end date has not passed the current day in the schedule period                     
                                                            if(!(date.isAfter(LocalDate.parse(contract1.getContractEndDate())))){

                                                            //The following block of code then gets current number of working hours already assigned for the current employee

                                                            //first set variables for finding the current whole week (mon-sun)in the chosen schedule period and setting the start and end dates for this week
                                                            LocalDate startOfWeek1 = date.with(DayOfWeek.MONDAY);
                                                            LocalDate endOfWeek1 = date.with(DayOfWeek.SUNDAY);
                                                            //sets period of days to iterate through to check for existing shifts
                                                            long weekPeriod1 = startOfWeek1.until(endOfWeek1, DAYS)+1;

                                                            LocalDate day1 = startOfWeek1;

                                                                //for each day of the first week in the projected schedule period
                                                                for (int b=0; b < weekPeriod1; b++){                            

                                                                    //check if there are any existing shifts assigned
                                                                    if(DAO.checkEmployeeShift(employee1.getEmployeeID(), day1.format(formatter))==true){                                                                              

                                                                        //get the shift if it exists
                                                                        Shift shift1 = DAO.getEmployeeShift(employee1.getEmployeeID(), day1.format(formatter));

                                                                        //then check that this is a working shift using the shift type
                                                                        if(shift1.getShiftType().equalsIgnoreCase("1")){

                                                                            //if working shift then get the duration of hours and minutes for that shift    
                                                                            LocalTime shiftStart1 = LocalTime.parse(shift1.getShiftStart());
                                                                            LocalTime shiftEnd1 = LocalTime.parse(shift1.getShiftEnd());
                                                                            int hours3 = Duration.ofHours(24).plus(Duration.between(shiftStart1, shiftEnd1)).toHoursPart();
                                                                            double minutes3 = Double.parseDouble(df.format((Duration.between(shiftStart1, shiftEnd1).toMinutesPart())*0.0166)); 
                                                                            double duration3 = hours3 + minutes3;
                                                                            //set a variable for the day to 0 to store this duration
                                                                            double assignedHours4 = 0;

                                                                            //adds the duration to the day variable 
                                                                            assignedHours4 = Double.sum(assignedHours4, duration3);

                                                                            //passes the duration to a running total for the week
                                                                            assignedHours3 = Double.sum(assignedHours3, assignedHours4);  
                                                                            }
                                                                         }                                                                                                                                               
                                                                    //increment a day and continue the loop to get all assigned hours for that week 
                                                                    day1 = day1.plusDays(1);
                                                                }//end of calculating working hours for the week                                      


                                                                //hard constraint - now ensures the contracted weekly hours for the current employee will not been exceeded - if exceeded then will assign day off
                                                                if (!(Double.sum(assignedHours3, totalDuration) > Double.parseDouble(contract1.getContractedHours()))){

                                                                    /*hard constraint (sick days, annual leave, etc) - check if the current employee has a shift or any time-off booked already on 
                                                                    * the current date of the schedule period and if does, then to skip this day. 
                                                                    */
                                                                    if(!(DAO.checkEmployeeShift(employee1.getEmployeeID(), date.format(formatter))==true)){

                                                                    /*hard constraint - the following block checks if the employee has a shift booked the day before the current date as if does, will need to check the constraint 
                                                                    * for minimum hours between shifts has not been exceeded                        
                                                                    */

                                                                        //check if a shift exists the day before this day
                                                                        if(DAO.checkEmployeeShift(employee1.getEmployeeID(), date.minusDays(1).format(formatter))==true){

                                                                        //if the above is true, then get the shift
                                                                        Shift shift3 = DAO.getEmployeeShift(employee1.getEmployeeID(), date.minusDays(1).format(formatter));

                                                                            //now check if the shift is a working shift  
                                                                            if(shift3.getShiftType().equalsIgnoreCase("1")){

                                                                            //if working shift - get the duration between the end of this shift and the beginning of the proposed shift                                          
                                                                            LocalTime shiftEnd1 = LocalTime.parse(shift3.getShiftEnd());
                                                                            LocalTime shiftStart1 = startTime;
                                                                            int hours3 = Duration.ofHours(24).plus(Duration.between(shiftEnd1, shiftStart1)).toHoursPart();
                                                                            double minutes3 = Double.parseDouble(df.format((Duration.between(shiftEnd1, shiftStart1).toMinutesPart())*0.0166));
                                                                            double duration3 = hours3 + minutes3;

                                                                                //hard constraint - now check that minimum hours between shifts as stated in the employee contract has not been exceeded
                                                                                if(duration3 >= Double.parseDouble(contract1.getMinHoursBetweenShifts())){
                                                                                    
                                                                                    //before assigning the shift check for consecutive working days (soft constraint) before this date   
        
                                                                                    int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                                    LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                                    int consShifts2 = 0;
                                                                                    for (int c=0; c < consDays2; c++){
                                                                                     try{
                                                                                             Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                             if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                                 consShifts2 = consShifts2 + 1;
                                                                                             }                                                           
                                                                                         }
                                                                                     catch(NullPointerException s){
                                                                                             }
                                                                                     startConsDays2 = startConsDays2.plusDays(1);
                                                                                    }
                                                                                    
                                                                                    if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                        Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                        consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){
                                                                                                                                                                                                                               
                                                                                        //assign the working shift
                                                                                        DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);
                                                                                        //get updated number of working shifts currently assigned on this day
                                                                                         numOfShiftsOnDayAdded = numOfShiftsOnDayAdded +1;
                                                                                         break;
                                                                                    }
                                                                                    
                                                                                 }                                                        
                                                                              }
                                                                            else{
                                                                                int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                                LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                                int consShifts2 = 0;
                                                                                for (int c=0; c < consDays2; c++){
                                                                                 try{
                                                                                         Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                         if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                             consShifts2 = consShifts2 + 1;
                                                                                         }                                                           
                                                                                     }
                                                                                 catch(NullPointerException s){
                                                                                         }
                                                                                 startConsDays2 = startConsDays2.plusDays(1);
                                                                                }

                                                                                if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                        Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                        consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){

                                                                                        //assign the working shift
                                                                                        DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);
                                                                                        //get updated number of working shifts currently assigned on this day
                                                                                         numOfShiftsOnDayAdded = numOfShiftsOnDayAdded +1;
                                                                                         break;
                                                                                }
                                                                            }
                                                                         }
                                                                        else{
                                                                            int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                            LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                            int consShifts2 = 0;
                                                                            for (int c=0; c < consDays2; c++){
                                                                             try{
                                                                                     Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                     if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                         consShifts2 = consShifts2 + 1;
                                                                                     }                                                           
                                                                                 }
                                                                             catch(NullPointerException s){
                                                                                     }
                                                                             startConsDays2 = startConsDays2.plusDays(1);
                                                                            }

                                                                            if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                    Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                    consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){

                                                                                    //assign the working shift
                                                                                    DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);
                                                                                    //get updated number of working shifts currently assigned on this day
                                                                                    numOfShiftsOnDayAdded = numOfShiftsOnDayAdded +1;
                                                                                    break;
                                                                            }
                                                                        }
                                                                    }                                                                                                                                  
                                                                }
                                                            }
                                                        }
                                                        if(numOfShiftsOnDayAdded>0){
                                                            break;
                                                        }
                                                    }
                                                    else{
                                                         //assign the working shift
                                                         DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                                                         //System.out.println("Working shift assigned at line 2496 for "+employee.getEmployeeName()+" "+date);
                                                    }
                                                }                                                                                                                                                                                     
                                            }
                                     }
                                }
                            }                                                                       
                     }           
                }
                //Distribute remaining shifts required 
                try{
                    if(intRemainder1>0){
                        System.out.println(intRemainder1);
                        Collections.shuffle(priorityDayTextFields);
                                                    
                            for (TextField day : priorityDayTextFields){                                      
                                
                                if(day.equals(mon) && Integer.parseInt(mon.getText()) < monOldValue){                                    
                                    if(intRemainder1>0){
                                        mon.setText(String.valueOf(Integer.valueOf(1)));
                                      intRemainder1 = intRemainder1 -1;
                                    }
                                    else{
                                        mon.setText(String.valueOf(0));
                                    }
                                } 
                                if(day.equals(mon) && Integer.parseInt(mon.getText()) >= monOldValue){
                                    mon.setText(String.valueOf(0));
                                }
                                if(day.equals(tue) && Integer.parseInt(tue.getText()) < tueOldValue){
                                    if(intRemainder1>0){
                                        tue.setText(String.valueOf(1));
                                    intRemainder1 = intRemainder1 -1;
                                  }
                                    else{
                                        tue.setText(String.valueOf(0));
                                    }
                                }
                                if(day.equals(tue) && Integer.parseInt(tue.getText()) >= tueOldValue){
                                    tue.setText(String.valueOf(0));
                                }
                                if(day.equals(wed) && Integer.parseInt(wed.getText()) < wedOldValue){
                                    if(intRemainder1>0){
                                        wed.setText(String.valueOf(1));
                                    intRemainder1 = intRemainder1 -1;
                                  }
                                    else{
                                        wed.setText(String.valueOf(0));
                                    }
                                }
                                if(day.equals(wed) && Integer.parseInt(wed.getText()) >= wedOldValue){
                                    wed.setText(String.valueOf(0));
                                }
                                if(day.equals(thu) && Integer.parseInt(thu.getText()) < thuOldValue){

                                    if(intRemainder1>0){
                                        thu.setText(String.valueOf(1));
                                    intRemainder1 = intRemainder1 -1;
                                  }
                                    else{
                                        thu.setText(String.valueOf(0));
                                    }
                                }
                                if(day.equals(thu) && Integer.parseInt(thu.getText()) >= thuOldValue){
                                    thu.setText(String.valueOf(0));
                                }
                                if(day.equals(fri) && Integer.parseInt(fri.getText()) < friOldValue){

                                    if(intRemainder1>0){
                                        fri.setText(String.valueOf(1));
                                    intRemainder1 = intRemainder1 -1;
                                  }
                                    else{
                                        fri.setText(String.valueOf(0));
                                    }
                                }
                                if(day.equals(fri) && Integer.parseInt(fri.getText()) >= friOldValue){
                                    fri.setText(String.valueOf(0));
                                }
                                if(day.equals(sat) && Integer.parseInt(sat.getText()) < satOldValue){

                                    if(intRemainder1>0){
                                        sat.setText(String.valueOf(1));
                                    intRemainder1 = intRemainder1 -1;
                                  }
                                    else{
                                        sat.setText(String.valueOf(0));
                                    }
                                }
                                if(day.equals(sat) && Integer.parseInt(sat.getText()) >= satOldValue){
                                    sat.setText(String.valueOf(0));
                                }
                                if(day.equals(sun) && Integer.parseInt(sun.getText()) < sunOldValue){
                                   if(intRemainder1>0){
                                        sun.setText(String.valueOf(1));
                                    intRemainder1 = intRemainder1 -1;
                                  }
                                   else{
                                        sun.setText(String.valueOf(0));
                                    }
                                }
                                if(day.equals(sun) && Integer.parseInt(sun.getText()) >= sunOldValue){
                                    sun.setText(String.valueOf(0));
                                }
                            }
                    addRemainingShifts();//this will attempt to add any remaining shifts possible to maximise allocation
                    //return values to original to check which days are supposed to have zero employees
                    mon.setText(String.valueOf(monOldValue));
                    tue.setText(String.valueOf(tueOldValue));
                    wed.setText(String.valueOf(wedOldValue));
                    thu.setText(String.valueOf(thuOldValue));
                    fri.setText(String.valueOf(friOldValue));
                    sat.setText(String.valueOf(satOldValue));
                    sun.setText(String.valueOf(sunOldValue));
                    }
                }catch(NumberFormatException e){
                      
                  }
                
                try{
                //finally assign the days off
                for (LocalDate date : dates){
                 
                  if ((date.getDayOfWeek().getValue()==1 && Integer.parseInt(mon.getText())==0) ||
                      (date.getDayOfWeek().getValue()==2 && Integer.parseInt(tue.getText())==0) ||
                      (date.getDayOfWeek().getValue()==3 && Integer.parseInt(wed.getText())==0) ||
                      (date.getDayOfWeek().getValue()==4 && Integer.parseInt(thu.getText())==0) ||
                      (date.getDayOfWeek().getValue()==5 && Integer.parseInt(fri.getText())==0) ||
                      (date.getDayOfWeek().getValue()==6 && Integer.parseInt(sat.getText())==0) ||
                      (date.getDayOfWeek().getValue()==7 && Integer.parseInt(sun.getText())==0)){
                      
                      continue;
                  }                 
                  else{
                    for (Employee employee : employeesSelected){
                        
                        if(!(DAO.checkEmployeeShift(employee.getEmployeeID(), date.format(formatter))==true)){
                            
                            DAO.createShift(employee.getEmployeeID(), date.format(formatter), LocalTime.of(00, 00), LocalTime.of(00, 00), 1, 2, 0);                            
                        }                        
                    }
                  }                    
                }
                }catch(NumberFormatException n){
                     
                 }
                  //System.out.println("Finished loop");
                  Stage autoShedule = (Stage) this.autoShiftCancelButton.getScene().getWindow();
                  autoShedule.close();
                  
                  refreshCalendar();//update the calendar                 
            }          
        }
       }catch(Exception e){
           e.printStackTrace();
       }
       
    }
    
    
    private void addRemainingShifts() throws ClassNotFoundException, SQLException, ParseException{
        
        //variables for the start and end dates of chosen schedule period
        LocalDate startDate = scheduleFromDate.getValue();
        LocalDate endDate = scheduleToDate.getValue(); 
        
        //variable for the selected shift pattern
        int shiftPattern = shiftPatternComboBox.getSelectionModel().getSelectedIndex()+1;
        
        //variable for the selected shift type
        int shiftType =  shiftTypeComboBox.getSelectionModel().getSelectedIndex()+1;
        
        //start and end times for chosen shift period
        LocalTime startTime = LocalTime.of(Integer.parseInt(startTimeHours.getSelectionModel().getSelectedItem()), Integer.parseInt(startTimeMinutes.getSelectionModel().getSelectedItem()));
        LocalTime finishTime = LocalTime.of(Integer.parseInt(finishTimeHours.getSelectionModel().getSelectedItem()), Integer.parseInt(finishTimeMinutes.getSelectionModel().getSelectedItem()));
        
        //variable for days between start and end dates for the selected schedule period
        long schedulePeriod = ChronoUnit.DAYS.between(startDate, endDate)+1;
        
        //variable for total number of hours in a assigned/selected shift
        int totalHours = Duration.ofHours(24).plus(Duration.between(startTime, finishTime)).toHoursPart();
           
        //variable for the minutes part of a assigned/selected shift. For example 8 hours and 15 minutes. This value would be 15 minutes.
        double totalMinutes = Double.parseDouble(df.format((Duration.between(startTime, finishTime).toMinutesPart())*0.0166));        
        
        //variable for total duration of a assigned shift
        double totalDuration = totalHours + totalMinutes;
        
        //variable shift cost value
        double shiftCost;
        
        //variable for holding the number of hours assigned to an employee in a week to evaluate for not exceeding the weekly contracted hours.
        double assignedHours1;                     
                                        
            LocalDate scheduleDate = scheduleFromDate.getValue(); //set another start date variable (this will change in loops) as the first date in the selected shedule period                
            ArrayList<LocalDate> dates = new ArrayList<>();//these are priority dates if selected by the shift planner under optional settings unless all are selected
            ArrayList<LocalDate> dates2 = new ArrayList<>();//these will be randomised and less prioritised                                                               

            employeesSelected.addAll(selectedEmployeesTable.getItems()); //get the employees and add to an ArrayList                 
            Collections.shuffle(employeesSelected);//randomise order of employees so a fair distribution of shifts can be acheived                 
            employeesSelected2.addAll(selectedEmployeesTable.getItems()); //a copy of the list to be shuffled later and used in other search loops  


                
                //At least one of these must be selected from previous method                                
                if(monTick.isSelected() || tueTick.isSelected() || wedTick.isSelected() || thuTick.isSelected() ||
                         friTick.isSelected() || satTick.isSelected() || sunTick.isSelected()){                         
                    
                    int sublist = 0;//index counter for randomising (later) dates which are not selected under optional settings   
                      
                    for (int i=0; i<schedulePeriod; i++){
                        
                        if (scheduleDate.getDayOfWeek().getValue()==1 && (monTick.isSelected() && Integer.parseInt(mon.getText())>0)){
                            
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1;                                                        
                        }
                        else if(scheduleDate.getDayOfWeek().getValue()==2 && (tueTick.isSelected() && Integer.parseInt(tue.getText())>0)){
                            
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1; 
                        }  
                        else if(scheduleDate.getDayOfWeek().getValue()==3 && (wedTick.isSelected() && Integer.parseInt(wed.getText())>0)){
                            
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1; 
                        }
                        else if(scheduleDate.getDayOfWeek().getValue()==4 && (thuTick.isSelected() && Integer.parseInt(thu.getText())>0)){
                            
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1; 
                        }
                        else if(scheduleDate.getDayOfWeek().getValue()==5 && (friTick.isSelected() && Integer.parseInt(fri.getText())>0)){
                            
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1; 
                        }
                        else if(scheduleDate.getDayOfWeek().getValue()==6 && (satTick.isSelected() && Integer.parseInt(sat.getText())>0)){
                            
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1; 
                        }
                        else if(scheduleDate.getDayOfWeek().getValue()==7 && (sunTick.isSelected() && Integer.parseInt(sun.getText())>0)){
                                                        
                            dates.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                            sublist = sublist+1; 
                        }
                        else{
                            dates2.add(scheduleDate);
                            scheduleDate = scheduleDate.plusDays(1);
                        }
                        
                    }
                    Collections.shuffle(dates);//randomise these priority dates first 
                    
                    if(dates2.isEmpty()==false){
                        dates.addAll(dates2); //then add the lesser priority dates                                                                 
                        Collections.shuffle(dates.subList(sublist, dates.size()));//finally randomise the lesser priority dates from index sublist
                    }
                    
                                    
                }                  
                                                                         
                //for each day in the schedule period
                //for (int i=0; i < schedulePeriod; i++){
                for (LocalDate date : dates){     
                    Collections.shuffle(employeesSelected);//randomise employees per day
                                                                
                      //for each employee selected for the projected schedule period  
                      for (Employee employee : employeesSelected){                          
                          
                        //get number of working shifts currently assigned on this day
                        int numOfShiftsOnDay = DAO.getNumOfShiftsOnDay(date.format(formatter)); 
                        int numOfShiftsOnDayAdded = 0;
                          
                        //set weekly assigned/allocated hours counter to 0  
                        assignedHours1=0;                                               
                        
                        //get and store employee contract from database as we will need this for contract constraint checks
                        Contract contract = DAO.getContract(employee.getEmployeeContract());
                        
                        //store shift cost for each shift that will be created, based on the hourly rate from the employee contract multiplied by the 
                        //duration of hours for the selected shift. This figure will be used at the point of assigning a shift.
                        shiftCost = Double.parseDouble(df.format((DAO.getHourlyRate(employee.getEmployeeID())) * totalDuration));                                   
                                
                                                                    
                        /*The following block of code then gets current number of working hours already assigned for the current employee, for the current week of current day
                        *of the projected schedule period.
                        */
                            //first set variables for finding the current whole week (mon-sun)in the chosen schedule period and setting the start and end dates for this week
                            LocalDate startOfWeek = date.with(DayOfWeek.MONDAY);
                            LocalDate endOfWeek = date.with(DayOfWeek.SUNDAY);
                            //sets period of days to iterate through to check for existing shifts
                            long weekPeriod = startOfWeek.until(endOfWeek, DAYS)+1;
                                                       
                            LocalDate day = startOfWeek;
                                                                                    
                                //for each day of the first week in the projected schedule period
                                for (int a=0; a < weekPeriod; a++){                            

                                    //check if there are any existing shifts assigned
                                    if(DAO.checkEmployeeShift(employee.getEmployeeID(), day.format(formatter))==true){                                                                              
                                        
                                        //get the shift if it exists
                                        Shift shift = DAO.getEmployeeShift(employee.getEmployeeID(), day.format(formatter));
                                        
                                        //then check that this is a working shift using the shift type
                                        if(shift.getShiftType().equalsIgnoreCase("1")){
                                        
                                        //if working shift then get the duration of hours and minutes for that shift    
                                        LocalTime shiftStart = LocalTime.parse(shift.getShiftStart());
                                        LocalTime shiftEnd = LocalTime.parse(shift.getShiftEnd());
                                        int hours1 = Duration.ofHours(24).plus(Duration.between(shiftStart, shiftEnd)).toHoursPart();
                                        double minutes1 = Double.parseDouble(df.format((Duration.between(shiftStart, shiftEnd).toMinutesPart())*0.0166)); 
                                        double duration1 = hours1 + minutes1;
                                        //set a variable for the day to 0 to store this duration
                                        double assignedHours2 = 0;

                                        //adds the duration to the day variable 
                                        assignedHours2 = Double.sum(assignedHours2, duration1);
                                        
                                        //passes the duration to a running total for the week
                                        assignedHours1 = Double.sum(assignedHours1, assignedHours2);  
                                        }
                                     }                                                                                                                                               
                                    //increment a day and continue the loop to get all assigned hours for that week 
                                    day = day.plusDays(1);
                                }//end of calculating working hours for the week                                      
                                
                            //hard constraint - check if ocntracted hours have been exceeded
                            if (!(Double.sum(assignedHours1, totalDuration) > Double.parseDouble(contract.getContractedHours()))){                                
                                                                                             
                                /*hard constraint (sick days, annual leave, etc) - check if the current employee has a shift or any time-off booked already on 
                                * the current date of the schedule period and if does, then to skip this day. 
                                */
                                if(!(DAO.checkEmployeeShift(employee.getEmployeeID(), date.format(formatter))==true)){
                                    
                                     /*hard constraint - the following block checks if the employee has a shift booked the day before the current date as if does, will need to check the constraint 
                                     * for minimum hours between shifts has not been exceeded                        
                                     */
                                     
                                     //check if a shift exists the day before this day
                                     if(DAO.checkEmployeeShift(employee.getEmployeeID(), date.minusDays(1).format(formatter))==true){
                                         
                                        //if the above is true, then get the shift
                                        Shift shift2 = DAO.getEmployeeShift(employee.getEmployeeID(), date.minusDays(1).format(formatter));
                                       
                                        //now check if the shift is a working shift  
                                        if(shift2.getShiftType().equalsIgnoreCase("1")){
                                           
                                         //if working shift - get the duration between the end of this shift and the beginning of the proposed shift as none working shifts would have zero duration                                          
                                         LocalTime shiftEnd = LocalTime.parse(shift2.getShiftEnd());
                                         LocalTime shiftStart = startTime;
                                         int hours2 = Duration.ofHours(24).plus(Duration.between(shiftEnd, shiftStart)).toHoursPart();
                                         double minutes2 = Double.parseDouble(df.format((Duration.between(shiftEnd, shiftStart).toMinutesPart())*0.0166));
                                         double duration2 = hours2 + minutes2;
                                                                                  
                                                                     
                                            //hard constraint - now check that minimum hours between shifts as stated in the employee contract has not been exceeded
                                            if(duration2 >= Double.parseDouble(contract.getMinHoursBetweenShifts())){                                               

                                                //Now hard constraints checks finished consider any demands set by shift planner (staff required per day) and all soft constraints                                                                                                
                                                  
                                                //check that the number of currently assigned shifts have not exceeded the required limit for the day
                                                if( ((date.getDayOfWeek().getValue()==1) && (monTick.isSelected() && Integer.parseInt(mon.getText())>0) && (numOfShiftsOnDay<monOldValue)) || 
                                                    ((date.getDayOfWeek().getValue()==2) && (tueTick.isSelected() && Integer.parseInt(tue.getText())>0) && (numOfShiftsOnDay<tueOldValue)) ||
                                                    ((date.getDayOfWeek().getValue()==3) && (wedTick.isSelected() && Integer.parseInt(wed.getText())>0) && (numOfShiftsOnDay<wedOldValue)) ||
                                                    ((date.getDayOfWeek().getValue()==4) && (thuTick.isSelected() && Integer.parseInt(thu.getText())>0) && (numOfShiftsOnDay<thuOldValue)) ||
                                                    ((date.getDayOfWeek().getValue()==5) && (friTick.isSelected() && Integer.parseInt(fri.getText())>0) && (numOfShiftsOnDay<friOldValue)) ||
                                                    ((date.getDayOfWeek().getValue()==6) && (satTick.isSelected() && Integer.parseInt(sat.getText())>0) && (numOfShiftsOnDay<satOldValue)) ||
                                                    ((date.getDayOfWeek().getValue()==7) && (sunTick.isSelected() && Integer.parseInt(sun.getText())>0) && (numOfShiftsOnDay<sunOldValue))){                                                                                                           
                                                    
        //////////////////////                        //get consecutive days/shifts count for current employee                   
                                                      int consDays1 = Integer.parseInt(contract.getMaxConsWorkDays());
                                                      LocalDate startConsDays1 = date.minusDays(consDays1); 
                                                      int consShifts1 = 0;
                                                       
                                                       for (int b=0; b < consDays1; b++){
                                                        try{
                                                                Shift shift3 = DAO.getEmployeeShift(employee.getEmployeeID(), startConsDays1.format(formatter));
                                                                if (shift3.getShiftType().equalsIgnoreCase("1")){
                                                                    consShifts1 = consShifts1 + 1;
                                                                }                                                           
                                                            }
                                                        catch(NullPointerException s){
                                                                }
                                                        startConsDays1 = startConsDays1.plusDays(1);
                                                       }                                                                                                  
                                                    
                                                    /*if either of the current employee's preferred days off are on this weekday or consecutive days are reached 
                                                    * then look for another employee who would better suit this day
                                                    */
                                                    if (Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                        Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                        consShifts1 >= Integer.parseInt(contract.getMaxConsWorkDays())){
                                                        
                                                        Collections.shuffle(employeesSelected2);
                                                        //Now we will check if any other employees are available instead - will aim to find the next available only
                                                        for (Employee employee1 : employeesSelected2){
                                                            
                                                            //set assigned/allocated hours count to 0  
                                                            double assignedHours3=0;

                                                            //get and store employee contract (in this current loop) from database as we will need this for contract constraint checks
                                                            Contract contract1 = DAO.getContract(employee1.getEmployeeContract());

                                                            //store shift cost for the shift that will be created
                                                            double shiftCost1 = Double.parseDouble(df.format((DAO.getHourlyRate(employee1.getEmployeeID())) * totalDuration));                                   

                                                            //hard constraint - check that the current employee contract end date has not passed the current day in the schedule period                     
                                                            if(!(date.isAfter(LocalDate.parse(contract1.getContractEndDate())))){

                                                            //The following block of code then gets current number of working hours already assigned for the current employee
                                                            
                                                                //first set variables for finding the current whole week (mon-sun)in the chosen schedule period and setting the start and end dates for this week
                                                                LocalDate startOfWeek1 = date.with(DayOfWeek.MONDAY);
                                                                LocalDate endOfWeek1 = date.with(DayOfWeek.SUNDAY);
                                                                //sets period of days to iterate through to check for existing shifts
                                                                long weekPeriod1 = startOfWeek1.until(endOfWeek1, DAYS)+1;

                                                                LocalDate day1 = startOfWeek1;

                                                                    //for each day of the week in the projected schedule period
                                                                    for (int b=0; b < weekPeriod1; b++){                            

                                                                        //check if there are any existing shifts assigned
                                                                        if(DAO.checkEmployeeShift(employee1.getEmployeeID(), day1.format(formatter))==true){                                                                              

                                                                            //get the shift if it exists
                                                                            Shift shift1 = DAO.getEmployeeShift(employee1.getEmployeeID(), day1.format(formatter));

                                                                            //then check that this is a working shift using the shift type
                                                                            if(shift1.getShiftType().equalsIgnoreCase("1")){

                                                                                //if working shift then get the duration of hours and minutes for that shift    
                                                                                LocalTime shiftStart1 = LocalTime.parse(shift1.getShiftStart());
                                                                                LocalTime shiftEnd1 = LocalTime.parse(shift1.getShiftEnd());
                                                                                int hours3 = Duration.ofHours(24).plus(Duration.between(shiftStart1, shiftEnd1)).toHoursPart();
                                                                                double minutes3 = Double.parseDouble(df.format((Duration.between(shiftStart1, shiftEnd1).toMinutesPart())*0.0166)); 
                                                                                double duration3 = hours3 + minutes3;
                                                                                //set a variable for the day to 0 to store this duration
                                                                                double assignedHours4 = 0;

                                                                                //adds the duration to the day variable 
                                                                                assignedHours4 = Double.sum(assignedHours4, duration3);

                                                                                //passes the duration to a running total for the week
                                                                                assignedHours3 = Double.sum(assignedHours3, assignedHours4);  
                                                                            }
                                                                         }                                                                                                                                               
                                                                        //increment a day and continue the loop to get all assigned hours for that week 
                                                                        day1 = day1.plusDays(1);
                                                                    }//end of calculating working hours for the week                                      


                                                                    //hard constraint - now ensures the contracted weekly hours for the current employee will not been exceeded - if exceeded then will assign day off
                                                                    if (!(Double.sum(assignedHours3, totalDuration) > Double.parseDouble(contract1.getContractedHours()))){

                                                                        /*hard constraint (sick days, annual leave, etc) - check if the current employee has a shift or any time-off booked already on 
                                                                        * the current date of the schedule period and if does, then to skip this day. 
                                                                        */
                                                                        if(!(DAO.checkEmployeeShift(employee1.getEmployeeID(), date.format(formatter))==true)){

                                                                        /*hard constraint - the following block checks if the employee has a shift booked the day before the current date as if does, will need to check the constraint 
                                                                        * for minimum hours between shifts has not been exceeded                        
                                                                        */

                                                                         //check if a shift exists the day before this day
                                                                         if(DAO.checkEmployeeShift(employee1.getEmployeeID(), date.minusDays(1).format(formatter))==true){

                                                                             //if the above is true, then get the shift
                                                                             Shift shift3 = DAO.getEmployeeShift(employee1.getEmployeeID(), date.minusDays(1).format(formatter));

                                                                            //now check if the shift is a working shift  
                                                                            if(shift3.getShiftType().equalsIgnoreCase("1")){

                                                                             //if working shift - get the duration between the end of this shift and the beginning of the proposed shift                                          
                                                                             LocalTime shiftEnd1 = LocalTime.parse(shift3.getShiftEnd());
                                                                             LocalTime shiftStart1 = startTime;
                                                                             int hours3 = Duration.ofHours(24).plus(Duration.between(shiftEnd1, shiftStart1)).toHoursPart();
                                                                             double minutes3 = Double.parseDouble(df.format((Duration.between(shiftEnd1, shiftStart1).toMinutesPart())*0.0166));
                                                                             double duration3 = hours3 + minutes3;


                                                                                //hard constraint - now check that minimum hours between shifts as stated in the employee contract has not been exceeded
                                                                                if(duration3 >= Double.parseDouble(contract1.getMinHoursBetweenShifts())){
                                                                                    
                                                                                    //before assigning the shift check for consecutive working days (soft constraint) before this date                                                                  
                                                                                           int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                                           LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                                           int consShifts2 = 0;
                                                                                           for (int c=0; c < consDays2; c++){
                                                                                            try{
                                                                                                    Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                                    if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                                        consShifts2 = consShifts2 + 1;
                                                                                                    }                                                           
                                                                                                }
                                                                                            catch(NullPointerException s){
                                                                                                    }
                                                                                            startConsDays2 = startConsDays2.plusDays(1);
                                                                                           }
                                                                                    //System.out.println("employee1 at line: 1785 "+employee1.getEmployeeName());
                                                                                    if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                        Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                        consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){
                                                                                                                                                                                                                               
                                                                                        //assign the working shift
                                                                                        DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);

                                                                                        //get updated number of working shifts currently assigned on this day
                                                                                        numOfShiftsOnDayAdded = numOfShiftsOnDayAdded +1;
                                                                                        break;                                                                                                                                                                                                                                                                                                
                                                                                      }                                                                                    
                                                                                 }                                                        
                                                                              }
                                                                            else{
                                                                                //System.out.println("employee1 at line: 1803 "+employee1.getEmployeeName());
                                                                                //before assigning the shift check for consecutive working days (soft constraint) before this date                                                                  
                                                                               int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                               LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                               int consShifts2 = 0;
                                                                               for (int c=0; c < consDays2; c++){
                                                                                try{
                                                                                        Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                        if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                            consShifts2 = consShifts2 + 1;
                                                                                        }                                                           
                                                                                    }
                                                                                catch(NullPointerException s){
                                                                                        }
                                                                                startConsDays2 = startConsDays2.plusDays(1);
                                                                               }
                                                                               
                                                                               if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                    Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                    consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){
                                                                                                                                                                                                                               
                                                                                    //assign the working shift
                                                                                    DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);
                                                                                    numOfShiftsOnDayAdded = numOfShiftsOnDayAdded +1;
                                                                                    break;                                                                                                                                                                                                                                                                           
                                                                                }
                                                                            }
                                                                         }
                                                                         else{
                                                                                //System.out.println("employee1 at line: 1838 "+employee1.getEmployeeName());
                                                                                //before assigning the shift check for consecutive working days (soft constraint) before this date                                                                  
                                                                               int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                               LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                               int consShifts2 = 0;
                                                                               for (int c=0; c < consDays2; c++){
                                                                                try{
                                                                                        Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                        if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                            consShifts2 = consShifts2 + 1;
                                                                                        }                                                           
                                                                                    }
                                                                                catch(NullPointerException s){
                                                                                        }
                                                                                startConsDays2 = startConsDays2.plusDays(1);
                                                                               }
                                                                               
                                                                               if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                    Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                    consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){
                                                                                                                                                                                                                               
                                                                                    //assign the working shift
                                                                                     DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);                                                                                                                                                               

                                                                                     //get updated number of working shifts currently assigned on this day
                                                                                     numOfShiftsOnDayAdded = numOfShiftsOnDayAdded +1;
                                                                                     break;                                                                                              
                                                                                }
                                                                            }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        if(numOfShiftsOnDayAdded>0){
                                                            break;
                                                        }                                                        
                                                    }
                                                    else{
                                                         //assign the working shift
                                                         DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                                                         //System.out.println("Working shift assigned at line 1885 for "+employee.getEmployeeName()+" "+date);
                                                    }                                                
                                                }                                                                                                                      
                                            }
                                        }
                                        else{
                                                //check that the number of currently assigned shifts have not exceeded the limit set under optional settings for the current day
                                                if( ((date.getDayOfWeek().getValue()==1) && (monTick.isSelected() && Integer.parseInt(mon.getText())>0) && (numOfShiftsOnDay<monOldValue)) || 
                                                    ((date.getDayOfWeek().getValue()==2) && (tueTick.isSelected() && Integer.parseInt(tue.getText())>0) && (numOfShiftsOnDay<tueOldValue)) ||
                                                    ((date.getDayOfWeek().getValue()==3) && (wedTick.isSelected() && Integer.parseInt(wed.getText())>0) && (numOfShiftsOnDay<wedOldValue)) ||
                                                    ((date.getDayOfWeek().getValue()==4) && (thuTick.isSelected() && Integer.parseInt(thu.getText())>0) && (numOfShiftsOnDay<thuOldValue)) ||
                                                    ((date.getDayOfWeek().getValue()==5) && (friTick.isSelected() && Integer.parseInt(fri.getText())>0) && (numOfShiftsOnDay<friOldValue)) ||
                                                    ((date.getDayOfWeek().getValue()==6) && (satTick.isSelected() && Integer.parseInt(sat.getText())>0) && (numOfShiftsOnDay<satOldValue)) ||
                                                    ((date.getDayOfWeek().getValue()==7) && (sunTick.isSelected() && Integer.parseInt(sun.getText())>0) && (numOfShiftsOnDay<sunOldValue))){
                                                                                                          
         //////////////////////                                           
                                                       int consDays1 = Integer.parseInt(contract.getMaxConsWorkDays());
                                                       LocalDate startConsDays1 = date.minusDays(consDays1); 
                                                       int consShifts1 = 0;
                                                       
                                                       for (int b=0; b < consDays1; b++){
                                                        try{
                                                            Shift shift3 = DAO.getEmployeeShift(employee.getEmployeeID(), startConsDays1.format(formatter));
                                                            if (shift3.getShiftType().equalsIgnoreCase("1")){
                                                                consShifts1 = consShifts1 + 1;
                                                            }                                                           
                                                        }
                                                        catch(NullPointerException s){
                                                                }
                                                        startConsDays1 = startConsDays1.plusDays(1);
                                                       }                                                                                                  
                                                    
                                                    /*if either of the current employee's preferred days off are on this weekday or consecutive days are reached 
                                                    * then look for another employee who may not prefer to be off on this day
                                                    */
                                                    if (Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                        Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                        consShifts1 >= Integer.parseInt(contract.getMaxConsWorkDays())){                                                                                                          
                                                        
                                                        Collections.shuffle(employeesSelected2);
                                                        //Now we will check if any other employees are available instead - will find the next available only
                                                        for (Employee employee1 : employeesSelected2){
                                                            
                                                            //set assigned/allocated hours count to 0  
                                                            double assignedHours3=0;

                                                            //get and store employee contract (in this current loop) from database as we will need this for contract constraint checks
                                                            Contract contract1 = DAO.getContract(employee1.getEmployeeContract());

                                                            //store shift cost for the shift that will be created
                                                            double shiftCost1 = Double.parseDouble(df.format((DAO.getHourlyRate(employee1.getEmployeeID())) * totalDuration));                                   

                                                            //hard constraint - check that the current employee contract end date has not passed the current day in the schedule period                     
                                                            if(!(date.isAfter(LocalDate.parse(contract1.getContractEndDate())))){

                                                            //The following block of code then gets current number of working hours already assigned for the current employee
                                                            
                                                                //first set variables for finding the current whole week (mon-sun)in the chosen schedule period and setting the start and end dates for this week
                                                                LocalDate startOfWeek1 = date.with(DayOfWeek.MONDAY);
                                                                LocalDate endOfWeek1 = date.with(DayOfWeek.SUNDAY);
                                                                //sets period of days to iterate through to check for existing shifts
                                                                long weekPeriod1 = startOfWeek1.until(endOfWeek1, DAYS)+1;

                                                                LocalDate day1 = startOfWeek1;

                                                                    //for each day of the first week in the projected schedule period
                                                                    for (int b=0; b < weekPeriod1; b++){                            

                                                                        //check if there are any existing shifts assigned
                                                                        if(DAO.checkEmployeeShift(employee1.getEmployeeID(), day1.format(formatter))==true){                                                                              

                                                                            //get the shift if it exists
                                                                            Shift shift1 = DAO.getEmployeeShift(employee1.getEmployeeID(), day1.format(formatter));

                                                                            //then check that this is a working shift using the shift type
                                                                            if(shift1.getShiftType().equalsIgnoreCase("1")){

                                                                                //if working shift then get the duration of hours and minutes for that shift    
                                                                                LocalTime shiftStart1 = LocalTime.parse(shift1.getShiftStart());
                                                                                LocalTime shiftEnd1 = LocalTime.parse(shift1.getShiftEnd());
                                                                                int hours3 = Duration.ofHours(24).plus(Duration.between(shiftStart1, shiftEnd1)).toHoursPart();
                                                                                double minutes3 = Double.parseDouble(df.format((Duration.between(shiftStart1, shiftEnd1).toMinutesPart())*0.0166)); 
                                                                                double duration3 = hours3 + minutes3;
                                                                                //set a variable for the day to 0 to store this duration
                                                                                double assignedHours4 = 0;

                                                                                //adds the duration to the day variable 
                                                                                assignedHours4 = Double.sum(assignedHours4, duration3);

                                                                                //passes the duration to a running total for the week
                                                                                assignedHours3 = Double.sum(assignedHours3, assignedHours4);  
                                                                            }
                                                                         }                                                                                                                                               
                                                                        //increment a day and continue the loop to get all assigned hours for that week 
                                                                        day1 = day1.plusDays(1);
                                                                    }//end of calculating working hours for the week                                      


                                                                    //hard constraint - now ensures the contracted weekly hours for the current employee will not been exceeded - if exceeded then will assign day off
                                                                    if (!(Double.sum(assignedHours3, totalDuration) > Double.parseDouble(contract1.getContractedHours()))){

                                                                        /*hard constraint (sick days, annual leave, etc) - check if the current employee has a shift or any time-off booked already on 
                                                                        * the current date of the schedule period and if does, then to skip this day. 
                                                                        */
                                                                        if(!(DAO.checkEmployeeShift(employee1.getEmployeeID(), date.format(formatter))==true)){

                                                                             /*hard constraint - the following block checks if the employee has a shift booked the day before the current date as if does, will need to check the constraint 
                                                                             * for minimum hours between shifts has not been exceeded                        
                                                                             */

                                                                         //check if a shift exists the day before this day
                                                                         if(DAO.checkEmployeeShift(employee1.getEmployeeID(), date.minusDays(1).format(formatter))==true){

                                                                             //if the above is true, then get the shift
                                                                             Shift shift3 = DAO.getEmployeeShift(employee1.getEmployeeID(), date.minusDays(1).format(formatter));

                                                                            //now check if the shift is a working shift  
                                                                            if(shift3.getShiftType().equalsIgnoreCase("1")){

                                                                             //if working shift - get the duration between the end of this shift and the beginning of the proposed shift                                          
                                                                             LocalTime shiftEnd1 = LocalTime.parse(shift3.getShiftEnd());
                                                                             LocalTime shiftStart1 = startTime;
                                                                             int hours3 = Duration.ofHours(24).plus(Duration.between(shiftEnd1, shiftStart1)).toHoursPart();
                                                                             double minutes3 = Double.parseDouble(df.format((Duration.between(shiftEnd1, shiftStart1).toMinutesPart())*0.0166));
                                                                             double duration3 = hours3 + minutes3;


                                                                                //hard constraint - now check that minimum hours between shifts as stated in the employee contract has not been exceeded
                                                                                if(duration3 >= Double.parseDouble(contract1.getMinHoursBetweenShifts())){
                                                                                    
                                                                                    //before assigning the shift check for consecutive working days (soft constraint) before this date   
                                                                               
                                                                                    int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                                    LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                                    int consShifts2 = 0;
                                                                                    
                                                                                        for (int c=0; c < consDays2; c++){
                                                                                         try{
                                                                                                 Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                                 if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                                     consShifts2 = consShifts2 + 1;
                                                                                                 }                                                           
                                                                                             }
                                                                                         catch(NullPointerException s){
                                                                                                 }
                                                                                         startConsDays2 = startConsDays2.plusDays(1);
                                                                                        }
                                                                                    
                                                                                        if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                            Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                            consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){

                                                                                            //assign the working shift
                                                                                            DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);                                                                                                                                                                                             
                                                                                            //update number of working shifts currently assigned on this day
                                                                                            numOfShiftsOnDayAdded = numOfShiftsOnDayAdded +1;
                                                                                            break;                                                                                                
                                                                                    }                                                                                    
                                                                                 }                                                                               
                                                                              }
                                                                            else{
                                                                                 //before assigning the shift check for consecutive working days (soft constraint) before this date   
                                                                               
                                                                                int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                                LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                                int consShifts2 = 0;
                                                                                
                                                                                for (int c=0; c < consDays2; c++){
                                                                                 try{
                                                                                    Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                    if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                        consShifts2 = consShifts2 + 1;
                                                                                    }                                                           
                                                                                     }
                                                                                 catch(NullPointerException s){
                                                                                         }
                                                                                 startConsDays2 = startConsDays2.plusDays(1);
                                                                                }
                                                                                    
                                                                                    if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                        Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                        consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){

                                                                                        //assign the working shift
                                                                                        DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);                  
                                                                                        //get updated number of working shifts currently assigned on this day
                                                                                        numOfShiftsOnDayAdded = numOfShiftsOnDayAdded +1;
                                                                                        break;
                                                                                    }
                                                                            }
                                                                         }
                                                                         else{
                                                                              //before assigning the shift check for consecutive working days (soft constraint) before this date   

                                                                            int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                            LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                            int consShifts2 = 0;
                                                                            for (int c=0; c < consDays2; c++){
                                                                             try{
                                                                                Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                    consShifts2 = consShifts2 + 1;
                                                                                }                                                           
                                                                                 }
                                                                             catch(NullPointerException s){
                                                                                     }
                                                                             startConsDays2 = startConsDays2.plusDays(1);
                                                                            }

                                                                             if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                                 Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                                 consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){

                                                                                 //assign the working shift
                                                                                DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);           
                                                                                //get updated number of working shifts currently assigned on this day
                                                                                numOfShiftsOnDayAdded = numOfShiftsOnDayAdded +1;
                                                                                break;
                                                                            }
                                                                         }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        if(numOfShiftsOnDayAdded>0){
                                                            break;
                                                        }
                                                    }
                                                    else{
                                                         //assign the working shift
                                                         DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                                                    }
                                                }                                                
                                        }
                                     }
                                     else{
                                         //check that the number of currently assigned shifts have not exceeded the limit set under optional settings for the current day
                                        if( ((date.getDayOfWeek().getValue()==1) && (monTick.isSelected() && Integer.parseInt(mon.getText())>0) && (numOfShiftsOnDay<monOldValue)) || 
                                            ((date.getDayOfWeek().getValue()==2) && (tueTick.isSelected() && Integer.parseInt(tue.getText())>0) && (numOfShiftsOnDay<tueOldValue)) ||
                                            ((date.getDayOfWeek().getValue()==3) && (wedTick.isSelected() && Integer.parseInt(wed.getText())>0) && (numOfShiftsOnDay<wedOldValue)) ||
                                            ((date.getDayOfWeek().getValue()==4) && (thuTick.isSelected() && Integer.parseInt(thu.getText())>0) && (numOfShiftsOnDay<thuOldValue)) ||
                                            ((date.getDayOfWeek().getValue()==5) && (friTick.isSelected() && Integer.parseInt(fri.getText())>0) && (numOfShiftsOnDay<friOldValue)) ||
                                            ((date.getDayOfWeek().getValue()==6) && (satTick.isSelected() && Integer.parseInt(sat.getText())>0) && (numOfShiftsOnDay<satOldValue)) ||
                                            ((date.getDayOfWeek().getValue()==7) && (sunTick.isSelected() && Integer.parseInt(sun.getText())>0) && (numOfShiftsOnDay<sunOldValue))){
                                                                                                          
    /////////////////                        //calculate consecutive days                   
                                              int consDays1 = Integer.parseInt(contract.getMaxConsWorkDays());
                                              LocalDate startConsDays1 = date.minusDays(consDays1); 
                                              int consShifts1 = 0;

                                                for (int b=0; b < consDays1; b++){
                                                 try{
                                                      Shift shift3 = DAO.getEmployeeShift(employee.getEmployeeID(), startConsDays1.format(formatter));
                                                      if (shift3.getShiftType().equalsIgnoreCase("1")){
                                                          consShifts1 = consShifts1 + 1;
                                                      }                                                           
                                                     }
                                                 catch(NullPointerException s){
                                                         }
                                                 startConsDays1 = startConsDays1.plusDays(1);
                                                }                                                                                                  
                                                    
                                                /*if either of the current employee's preferred days off are on this weekday or consecutive days are reached 
                                                * then look for another employee who may not prefer to be off on this day
                                                */
                                                if (Integer.parseInt((employee.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                    Integer.parseInt((employee.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                    consShifts1 >= Integer.parseInt(contract.getMaxConsWorkDays())){                                                                                                          
                                      
                                                    Collections.shuffle(employeesSelected2);
                                                    //Now we will check if any other employees are available instead - will find the next available only
                                                    for (Employee employee1 : employeesSelected2){

                                                        //set assigned/allocated hours count to 0  
                                                        double assignedHours3=0;

                                                        //get and store employee contract (in this current loop) from database as we will need this for contract constraint checks
                                                        Contract contract1 = DAO.getContract(employee1.getEmployeeContract());

                                                        //store shift cost for the shift that will be created
                                                        double shiftCost1 = Double.parseDouble(df.format((DAO.getHourlyRate(employee1.getEmployeeID())) * totalDuration));                                   

                                                        //hard constraint - check that the current employee contract end date has not passed the current day in the schedule period                     
                                                        if(!(date.isAfter(LocalDate.parse(contract1.getContractEndDate())))){

                                                        //The following block of code then gets current number of working hours already assigned for the current employee

                                                        //first set variables for finding the current whole week (mon-sun)in the chosen schedule period and setting the start and end dates for this week
                                                        LocalDate startOfWeek1 = date.with(DayOfWeek.MONDAY);
                                                        LocalDate endOfWeek1 = date.with(DayOfWeek.SUNDAY);
                                                        //sets period of days to iterate through to check for existing shifts
                                                        long weekPeriod1 = startOfWeek1.until(endOfWeek1, DAYS)+1;

                                                        LocalDate day1 = startOfWeek1;

                                                        //for each day of the first week in the projected schedule period
                                                        for (int b=0; b < weekPeriod1; b++){                            

                                                            //check if there are any existing shifts assigned
                                                            if(DAO.checkEmployeeShift(employee1.getEmployeeID(), day1.format(formatter))==true){                                                                              

                                                                //get the shift if it exists
                                                                Shift shift1 = DAO.getEmployeeShift(employee1.getEmployeeID(), day1.format(formatter));

                                                                //then check that this is a working shift using the shift type
                                                                if(shift1.getShiftType().equalsIgnoreCase("1")){

                                                                    //if working shift then get the duration of hours and minutes for that shift    
                                                                    LocalTime shiftStart1 = LocalTime.parse(shift1.getShiftStart());
                                                                    LocalTime shiftEnd1 = LocalTime.parse(shift1.getShiftEnd());
                                                                    int hours3 = Duration.ofHours(24).plus(Duration.between(shiftStart1, shiftEnd1)).toHoursPart();
                                                                    double minutes3 = Double.parseDouble(df.format((Duration.between(shiftStart1, shiftEnd1).toMinutesPart())*0.0166)); 
                                                                    double duration3 = hours3 + minutes3;
                                                                    //set a variable for the day to 0 to store this duration
                                                                    double assignedHours4 = 0;

                                                                    //adds the duration to the day variable 
                                                                    assignedHours4 = Double.sum(assignedHours4, duration3);

                                                                    //passes the duration to a running total for the week
                                                                    assignedHours3 = Double.sum(assignedHours3, assignedHours4);  
                                                                    }
                                                                 }                                                                                                                                               
                                                            //increment a day and continue the loop to get all assigned hours for that week 
                                                            day1 = day1.plusDays(1);
                                                        }//end of calculating working hours for the week                                      


                                                        //hard constraint - now ensures the contracted weekly hours for the current employee will not been exceeded - if exceeded then will assign day off
                                                        if (!(Double.sum(assignedHours3, totalDuration) > Double.parseDouble(contract1.getContractedHours()))){

                                                            /*hard constraint (sick days, annual leave, etc) - check if the current employee has a shift or any time-off booked already on 
                                                            * the current date of the schedule period and if does, then to skip this day. 
                                                            */
                                                            if(!(DAO.checkEmployeeShift(employee1.getEmployeeID(), date.format(formatter))==true)){

                                                            /*hard constraint - the following block checks if the employee has a shift booked the day before the current date as if does, will need to check the constraint 
                                                            * for minimum hours between shifts has not been exceeded                        
                                                            */

                                                                //check if a shift exists the day before this day
                                                                if(DAO.checkEmployeeShift(employee1.getEmployeeID(), date.minusDays(1).format(formatter))==true){

                                                                //if the above is true, then get the shift
                                                                Shift shift3 = DAO.getEmployeeShift(employee1.getEmployeeID(), date.minusDays(1).format(formatter));

                                                                    //now check if the shift is a working shift  
                                                                    if(shift3.getShiftType().equalsIgnoreCase("1")){

                                                                    //if working shift - get the duration between the end of this shift and the beginning of the proposed shift                                          
                                                                    LocalTime shiftEnd1 = LocalTime.parse(shift3.getShiftEnd());
                                                                    LocalTime shiftStart1 = startTime;
                                                                    int hours3 = Duration.ofHours(24).plus(Duration.between(shiftEnd1, shiftStart1)).toHoursPart();
                                                                    double minutes3 = Double.parseDouble(df.format((Duration.between(shiftEnd1, shiftStart1).toMinutesPart())*0.0166));
                                                                    double duration3 = hours3 + minutes3;

                                                                    //hard constraint - now check that minimum hours between shifts as stated in the employee contract has not been exceeded
                                                                    if(duration3 >= Double.parseDouble(contract1.getMinHoursBetweenShifts())){

                                                                        //before assigning the shift check for consecutive working days (soft constraint) before this date   

                                                                        int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                        LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                        int consShifts2 = 0;
                                                                        for (int c=0; c < consDays2; c++){
                                                                         try{
                                                                                 Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                                 if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                     consShifts2 = consShifts2 + 1;
                                                                                 }                                                           
                                                                             }
                                                                         catch(NullPointerException s){
                                                                                 }
                                                                         startConsDays2 = startConsDays2.plusDays(1);
                                                                        }
                                                                                    
                                                                        if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                            Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                            consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){

                                                                            //assign the working shift
                                                                            DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);
                                                                            //get updated number of working shifts currently assigned on this day
                                                                             numOfShiftsOnDayAdded = numOfShiftsOnDayAdded +1;
                                                                             break;
                                                                        }

                                                                     }                                                        
                                                                  }
                                                                else{
                                                                    int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                    LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                    int consShifts2 = 0;
                                                                    for (int c=0; c < consDays2; c++){
                                                                     try{
                                                                             Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                             if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                                 consShifts2 = consShifts2 + 1;
                                                                             }                                                           
                                                                         }
                                                                     catch(NullPointerException s){
                                                                             }
                                                                     startConsDays2 = startConsDays2.plusDays(1);
                                                                    }

                                                                    if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                            Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                            consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){

                                                                            //assign the working shift
                                                                            DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);
                                                                            //get updated number of working shifts currently assigned on this day
                                                                             numOfShiftsOnDayAdded = numOfShiftsOnDayAdded +1;
                                                                             break;
                                                                    }
                                                                }
                                                             }
                                                            else{
                                                                int consDays2 = Integer.parseInt(contract1.getMaxConsWorkDays());
                                                                LocalDate startConsDays2 = date.minusDays(consDays2); 
                                                                int consShifts2 = 0;
                                                                for (int c=0; c < consDays2; c++){
                                                                 try{
                                                                         Shift shift4 = DAO.getEmployeeShift(employee1.getEmployeeID(), startConsDays2.format(formatter));
                                                                         if (shift4.getShiftType().equalsIgnoreCase("1")){
                                                                             consShifts2 = consShifts2 + 1;
                                                                         }                                                           
                                                                     }
                                                                 catch(NullPointerException s){
                                                                         }
                                                                 startConsDays2 = startConsDays2.plusDays(1);
                                                                }

                                                                if (!(Integer.parseInt((employee1.getPreferredDayOff1()))==date.getDayOfWeek().getValue() || 
                                                                        Integer.parseInt((employee1.getPreferredDayOff2()))==date.getDayOfWeek().getValue() ||
                                                                        consShifts2 >= Integer.parseInt(contract1.getMaxConsWorkDays()))){

                                                                        //assign the working shift
                                                                        DAO.createShift(employee1.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost1);
                                                                        //get updated number of working shifts currently assigned on this day
                                                                        numOfShiftsOnDayAdded = numOfShiftsOnDayAdded +1;
                                                                        break;
                                                                }
                                                            }
                                                        }                                                                                                                                  
                                                    }
                                                }
                                            }
                                            if(numOfShiftsOnDayAdded>0){
                                                break;
                                            }
                                        }
                                        else{
                                             //assign the working shift
                                             DAO.createShift(employee.getEmployeeID(), date.format(formatter), startTime, finishTime, shiftPattern, shiftType, shiftCost);
                                             //System.out.println("Working shift assigned at line 2496 for "+employee.getEmployeeName()+" "+date);
                                        }
                                    }                                                                                                                                                                                     
                                }
                             }  
                        }                                                                       
                    }           
                }                
    }